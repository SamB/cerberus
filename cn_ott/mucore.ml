(* generated by Ott 0.31 from: mucore.ott *)


type 
core_object_type =  (* types for C objects *)
   OTy_integer
 | OTy_floating
 | OTy_pointer
 | OTy_array of core_object_type
 | OTy_struct of tag
 | OTy_union of tag


type 
core_base_type =  (* Core base types *)
   BTy_unit (* unit *)
 | BTy_boolean (* boolean *)
 | BTy_ctype (* Core type of C type exprs *)
 | BTy_list of core_base_type (* list *)
 | BTy_tuple of (core_base_type) list (* tuple *)
 | BTy_object of core_object_type (* C object value *)
 | BTy_loaded of core_object_type (* core_object_type or unspecified *)
 | BTy_storable (* top type for integer/float/pointer/structs (maybe union?). This is only used in the type system *)


type 
binop =  (* binary operators *)
   OpAdd
 | OpSub
 | OpMul
 | OpDiv
 | OpRem_t
 | OpRem_f
 | OpExp
 | OpEq
 | OpGt
 | OpLt
 | OpGe
 | OpLe
 | OpAnd
 | OpOr


type 
core_type =  (* Core types *)
   TyBase of core_base_type (* pure base type *)
 | TyEffect of core_base_type (* effectful base type *)


type 
polarity =  (* memory action polarities *)
   Pos (* sequenced by \ottkw{let\ weak} and \ottkw{let\ strong} *)
 | Neg (* only sequenced by \ottkw{let\ strong} *)


type 
'sym generic_name = 
   Sym of tyvarsym (* Core identifier *)
 | Impl of implementation__implementation_constant (* implementation-defined constant *)


type 
'sym generic_object_value =  (* C object values *)
   OVinteger of mem_integer_value (* integer value *)
 | OVfloating of mem_floating_value (* floating-point value *)
 | OVpointer of mem_pointer_value (* pointer value *)
 | OVarray of ('sym generic_loaded_value) list (* C array value *)
 | OVstruct of tag * ((cabs_cabs_identifier * ty * mem_mem_value)) list (* C struct value *)
 | OVunion of tag * cabs_cabs_identifier * mem_mem_value (* C union value *)

and 'sym generic_loaded_value =  (* potentially unspecified C object values *)
   LVspecified of 'sym generic_object_value (* non-unspecified loaded value *)
 | LVunspecified of ty (* unspecified loaded value *)


type 
'sym generic_value =  (* Core values *)
   Vobject of 'sym generic_object_value (* C object value *)
 | Vloaded of 'sym generic_loaded_value (* loaded C object value *)
 | Vunit
 | Vtrue
 | Vfalse
 | Vctype of ty (* C type as value *)
 | Vlist of core_base_type * ('sym generic_value) list
 | Vtuple of ('sym generic_value) list (* tuple *)


type 
'bty generic_ctor =  (* data constructors *)
   Cnil of bty (* empty list *)
 | Ccons (* list cons *)
 | Ctuple (* tuple *)
 | Carray (* C array *)
 | Civmax (* max integer value *)
 | Civmin (* min integer value *)
 | Civsizeof (* sizeof value *)
 | Civalignof (* alignof value *)
 | CivCOMPL (* bitwise complement *)
 | CivAND (* bitwise AND *)
 | CivOR (* bitwise OR *)
 | CivXOR (* bitwise XOR *)
 | Cspecified (* non-unspecified loaded value *)
 | Cunspecified (* unspecified loaded value *)
 | Cfvfromint (* cast integer to floating value *)
 | Civfromfloat (* cast floating to integer value *)


type 
'bty 'sym generic_pattern_aux = 
   CaseBase of maybesym_core_base_type
 | CaseCtor of 'bty generic_ctor * ('bty 'sym generic_pattern) list

and 'bty 'sym generic_pattern = 
   Pattern of annots * 'bty 'sym generic_pattern_aux


type 
'bty 'sym generic_pexpr_aux =  (* Core pure expressions *)
   PEsym of tyvarsym
 | PEimpl of implementation__implementation_constant (* implementation-defined constant *)
 | PEval of 'sym generic_value
 | PEconstrained of ((mem_mem_iv_constraint * tyvarsym)) list (* constrained value *)
 | PEundef of loc_t * undefined_undefined_behaviour (* undefined behaviour *)
 | PEerror of string * tyvarsym (* impl-defined static error *)
 | PEctor of 'bty generic_ctor * (tyvarsym) list (* data constructor application *)
 | PEarray_shift of tyvarsym * ty * tyvarsym (* pointer array shift *)
 | PEmember_shift of tyvarsym * tyvarsym * cabs_cabs_identifier (* pointer struct/union member shift *)
 | PEnot of tyvarsym (* boolean not *)
 | PEop of binop * tyvarsym * tyvarsym
 | PEstruct of tyvarsym * ((cabs_cabs_identifier * tyvarsym)) list (* C struct expression *)
 | PEunion of tyvarsym * cabs_cabs_identifier * tyvarsym (* C union expression *)
 | PEmemberof of tyvarsym * cabs_cabs_identifier * tyvarsym (* C struct/union member access *)
 | PEcall of 'sym generic_name * (tyvarsym) list (* pure function call *)
 | PEassert_undef of tyvarsym * undefined_undefined_behaviour
 | PEbool_to_integer of tyvarsym
 | PEconv_int of ty * tyvarsym
 | PEwrapI of ty * tyvarsym


type 
'bty 'sym generic_pexpr = 
   Pexpr of annots * bty * 'bty 'sym generic_pexpr_aux


type 
'bty 'sym generic_tpexpr =  (* Core top-level pure expressions *)
   PEcase of tyvarsym * (('bty 'sym generic_pattern * 'bty 'sym generic_tpexpr)) list (* pattern matching *)
 | PElet of 'bty 'sym generic_pattern * 'bty 'sym generic_tpexpr * 'bty 'sym generic_tpexpr (* pure let *)
 | PEif of tyvarsym * 'bty 'sym generic_tpexpr * 'bty 'sym generic_tpexpr (* pure if *)
 | PEdone of tyvarsym (* pure done *)


type 
'bty 'sym generic_action_aux =  (* memory actions *)
   Create of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * symbol_prefix
 | CreateReadOnly of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * symbol_prefix
 | Alloc of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * symbol_prefix
 | Kill of bool * 'bty 'sym generic_pexpr (* the boolean indicates whether the action is dynamic (i.e. free()) *)
 | Store of bool * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * cmm_memory_order (* the boolean indicates whether the store is locking *)
 | Load of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * cmm_memory_order
 | RMW of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * cmm_memory_order * cmm_memory_order
 | Fence of cmm_memory_order
 | CompareExchangeStrong of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * cmm_memory_order * cmm_memory_order
 | CompareExchangeWeak of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * cmm_memory_order * cmm_memory_order
 | LinuxFence of linux_linux_memory_order
 | LinuxLoad of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * linux_linux_memory_order
 | LinuxStore of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * linux_linux_memory_order
 | LinuxRMW of 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * linux_linux_memory_order


type 
'a 'bty 'sym generic_action = 
   Action of loc_t * a * 'bty 'sym generic_action_aux


type 
'a 'bty 'sym generic_paction =  (* memory actions with polarity *)
   Paction of polarity * 'a 'bty 'sym generic_action


type 
'a 'bty 'sym generic_expr_aux =  (* (effectful) expression *)
   Epure of 'bty 'sym generic_pexpr
 | Ememop of mem_memop * ('bty 'sym generic_pexpr) list (* pointer op involving memory *)
 | Eaction of 'a 'bty 'sym generic_paction (* memory action *)
 | Ecase of 'bty 'sym generic_pexpr * (('bty 'sym generic_pattern * 'a 'bty 'sym generic_expr)) list (* pattern matching *)
 | Elet of 'bty 'sym generic_pattern * 'bty 'sym generic_pexpr * 'a 'bty 'sym generic_expr
 | Eif of 'bty 'sym generic_pexpr * 'a 'bty 'sym generic_expr * 'a 'bty 'sym generic_expr
 | Eskip
 | Eccall of a * 'bty 'sym generic_pexpr * 'bty 'sym generic_pexpr * ('bty 'sym generic_pexpr) list (* C function call *)
 | Eproc of a * 'sym generic_name * ('bty 'sym generic_pexpr) list (* Core procedure call *)
 | Eunseq of ('a 'bty 'sym generic_expr) list (* unsequenced expressions *)
 | Ewseq of 'bty 'sym generic_pattern * 'a 'bty 'sym generic_expr * 'a 'bty 'sym generic_expr (* weak sequencing *)
 | Esseq of 'bty 'sym generic_pattern * 'a 'bty 'sym generic_expr * 'a 'bty 'sym generic_expr (* strong sequencing *)
 | Easeq of tyvarsym_base_type_pair * 'a 'bty 'sym generic_action * 'a 'bty 'sym generic_paction (* atomic sequencing *)
 | Eindet of nat * 'a 'bty 'sym generic_expr (* indeterminately sequenced expr *)
 | Ebound of nat * 'a 'bty 'sym generic_expr (* $\ldots$and boundary *)
 | End of ('a 'bty 'sym generic_expr) list (* nondeterministic sequencing *)
 | Esave of tyvarsym_base_type_pair * ((tyvarsym * core_base_type_pexpr_pair)) list * 'a 'bty 'sym generic_expr (* save label *)
 | Erun of a * tyvarsym * ('bty 'sym generic_pexpr) list (* run from label *)
 | Epar of ('a 'bty 'sym generic_expr) list (* cppmem-like thread creation *)
 | Ewait of thread_thread_id (* wait for thread termination *)

and 'a 'bty 'sym generic_expr = 
   Expr of annots * 'a 'bty 'sym generic_expr_aux


type
g = (termvar*T) list

(** definitions *)


