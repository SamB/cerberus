(* generated by Ott 0.31 from: mucore.ott *)


type 
base_type =  (* base types *)
   Unit (* unit *)
 | Bool (* boolean *)
 | Integer (* integer *)
 | Read (* rational numbers? *)
 | Loc (* location *)
 | Array of base_type (* array *)
 | ListTy of base_type (* list *)
 | TupleTy of (base_type) list (* tuple *)
 | Struct of tag (* struct *)
 | Set of base_type (* set *)
 | Option of base_type (* option *)
 | Param of (base_type) list * base_type (* parameter types *)


type 
'TY mu_object_value =  (* C object values (inhabitants of object types), which can be read/stored *)
   M_OVinteger of Impl_mem.integer_value (* integer value *)
 | M_OVpointer of Impl_mem.pointer_value (* pointer value *)
 | M_OVarray of ('TY mu_loaded_value) list (* C array value *)
 | M_OVstruct of Symbol.sym * ((Symbol.identifier * T.ct * Impl_mem.mem_value)) list (* C struct value *)
 | M_OVunion of Symbol.sym * Symbol.identifier * Impl_mem.mem_value (* C union value *)

and 'TY mu_loaded_value =  (* potentially unspecified C object values *)
   M_LVspecified of 'TY mu_object_value (* specified loaded value *)


type 
mu_ctor =  (* data constructors *)
   M_Cnil of T.bt (* empty list *)
 | M_Ccons (* list cons *)
 | M_Ctuple (* tuple *)
 | M_Carray (* C array *)
 | M_Civmax (* max integer value *)
 | M_Civmin (* min integer value *)
 | M_Civsizeof (* sizeof value *)
 | M_Civalignof (* alignof value *)
 | M_CivCOMPL (* bitwise complement *)
 | M_CivAND (* bitwise AND *)
 | M_CivOR (* bitwise OR *)
 | M_CivXOR (* bitwise XOR *)
 | M_Cspecified (* non-unspecified loaded value *)
 | M_Cfvfromint (* cast integer to floating value *)
 | M_Civfromfloat (* cast floating to integer value *)


type 
'TY mu_value =  (* Core values *)
   M_Vobject of 'TY mu_object_value (* C object value *)
 | M_Vloaded of 'TY mu_loaded_value (* loaded C object value *)
 | M_Vunit (* unit *)
 | M_Vtrue (* boolean true *)
 | M_Vfalse (* boolean false *)
 | M_Vlist of T.bt * ('TY mu_value) list (* list *)
 | M_Vtuple of ('TY mu_value) list (* tuple *)


type 
'TY mu_pval =  (* pure values *)
   M_PVsym of Symbol.sym (* Core identifier *)
 | M_PVimpl of Implementation.implementation_constant (* implementation-defined constant *)
 | M_PVmu_val of 'TY mu_value (* Core values *)
 | M_PVconstrained of ((Mem.mem_iv_constraint * 'TY mu_pval_aux)) list (* constrained value *)
 | M_PVerror of string * 'TY mu_pval_aux (* impl-defined static error *)
 | M_PVctor of mu_ctor * ('TY mu_pval_aux) list (* data constructor application *)
 | M_PVstruct of Symbol.sym * ((Symbol.identifier * 'TY mu_pval_aux)) list (* C struct expression *)
 | M_PVunion of Symbol.sym * Symbol.identifier * 'TY mu_pval_aux (* C union expression *)

and 'TY mu_pval_aux =  (* pure values with auxiliary info *)
   M_Pval of Location_ocaml.t * annot list * 'TY * 'TY mu_pval
 | M_Pval_no_aux of 'TY mu_pval (* Ott-hack for simpler typing rules *)


type 
'TY mu_tpval =  (* top-level pure values *)
   M_TPVundef of Location_ocaml.t * Undefined.undefined_behaviour (* undefined behaviour *)
 | M_TPVdone of 'TY mu_pval_aux (* pure done *)


type 
'TY mu_pexpr =  (* pure expressions *)
   M_PEpval of 'TY mu_pval_aux (* pure values *)
 | M_PEarray_shift of 'TY mu_pval_aux * T.ct * 'TY mu_pval_aux (* pointer array shift *)
 | M_PEmember_shift of 'TY mu_pval_aux * Symbol.sym * Symbol.identifier (* pointer struct/union member shift *)
 | M_PEnot of 'TY mu_pval_aux (* boolean not *)
 | M_PEop of Core.binop * 'TY mu_pval_aux * 'TY mu_pval_aux (* binary operations *)
 | M_PEmemberof of Symbol.sym * Symbol.identifier * 'TY mu_pval_aux (* C struct/union member access *)
 | M_PEcall of Symbol.sym Core.generic_name * ('TY mu_pval_aux) list (* pure function call *)
 | M_PEassert_undef of 'TY mu_pval_aux * Location_ocaml.t * Undefined.undefined_behaviour
 | M_PEbool_to_integer of 'TY mu_pval_aux
 | M_PEconv_int of 'TY act * 'TY mu_pval_aux
 | M_PEwrapI of 'TY act * 'TY mu_pval_aux


type 
mu_pattern = 
   M_CaseBase of ( Symbol.sym option * T.bt )
 | M_CaseCtor of mu_ctor * (mu_pattern_aux) list

and mu_pattern_aux = 
   M_Pattern of Location_ocaml.t * annot list * mu_pattern
 | M_Pat_no_aux of mu_pattern (* Ott-hack for simpler typing rules *)


type 
m_kill_kind = 
   M_Dynamic
 | M_Static of T.ct


type 
'TY mu_tpval_aux =  (* top-level pure values with location and annotations *)
   M_TPval of Location_ocaml.t * annot list * 'TY * 'TY mu_tpval
 | M_TPval_no_aux of 'TY mu_tpval (* Ott-hack for simpler typing rules *)


type 
'TY mu_pexpr_aux =  (* pure expressions with location and annotations *)
   M_Pexpr of Location_ocaml.t * annot list * 'TY * 'TY mu_pexpr
 | M_Pexpr_no_aux of 'TY mu_pexpr (* Ott-hack for simpler typing rules *)


type 
'TY mu_sym_or_pattern = 
   M_Symbol of Symbol.sym
 | M_Pat of mu_pattern_aux


type 
'TY mu_tpexpr =  (* top-level pure expressions *)
   M_TPEtpval of 'TY mu_tpval_aux (* top-level pure values *)
 | M_TPEcase of 'TY mu_pval_aux * ((mu_pattern_aux * 'TY mu_tpexpr_aux)) list (* pattern matching *)
 | M_TPElet of 'TY mu_sym_or_pattern * 'TY mu_pexpr_aux * 'TY mu_tpexpr_aux (* pure let *)
 | M_TPEif of 'TY mu_pval_aux * 'TY mu_tpexpr_aux * 'TY mu_tpexpr_aux (* pure if *)

and 'TY mu_tpexpr_aux =  (* pure top-level pure expressions with auxiliary info *)
   M_TPexpr of Location_ocaml.t * annot list * 'TY * 'TY mu_tpexpr
 | M_TPexpr_no_aux of 'TY mu_tpexpr (* Ott-hack for simpler typing rules *)


type 
lit = 
   Lit_Sym of 'sym
 | Lit_Unit
 | Lit_Bool of bool
 | Lit_Z of Z.t
 | Lit_Q of ( int * int )
 | Lit_Pointer of Z.t


type 
'TY mu_action =  (* memory actions *)
   M_Create of 'TY mu_pval_aux * 'TY act * Symbol.prefix
 | M_CreateReadOnly of 'TY mu_pval_aux * 'TY act * 'TY mu_pval_aux * Symbol.prefix
 | M_Alloc of 'TY mu_pval_aux * 'TY mu_pval_aux * Symbol.prefix
 | M_Kill of m_kill_kind * 'TY mu_pval_aux
 | M_Store of bool * 'TY act * 'TY mu_pval_aux * 'TY mu_pval_aux * Cmm_csem.memory_order (* true means store is locking *)
 | M_Load of 'TY act * 'TY mu_pval_aux * Cmm_csem.memory_order
 | M_RMW of 'TY act * 'TY mu_pval_aux * 'TY mu_pval_aux * 'TY mu_pval_aux * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_Fence of Cmm_csem.memory_order
 | M_CompareExchangeStrong of 'TY act * 'TY mu_pval_aux * 'TY mu_pval_aux * 'TY mu_pval_aux * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_CompareExchangeWeak of 'TY act * 'TY mu_pval_aux * 'TY mu_pval_aux * 'TY mu_pval_aux * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_LinuxFence of Linux.linux_memory_order
 | M_LinuxLoad of 'TY act * 'TY mu_pval_aux * Linux.linux_memory_order
 | M_LinuxStore of 'TY act * 'TY mu_pval_aux * 'TY mu_pval_aux * Linux.linux_memory_order
 | M_LinuxRMW of 'TY act * 'TY mu_pval_aux * 'TY mu_pval_aux * Linux.linux_memory_order


type 
'TY mu_action_aux =  (* memory actions with auxiliary info *)
   M_Action of Location_ocaml.t * 'TY mu_action
 | M_no_aux of 'TY mu_action (* Ott-hack for simpler typing rules *)


type 
'TY mu_seq_expr =  (* sequential (effectful) expressions *)
   M_Seq_Epval of 'TY mu_pval_aux (* pure values *)
 | M_Seq_Eccall of 'TY act * 'TY mu_pval_aux * ('TY mu_pval_aux) list (* C function call *)
 | M_Seq_Eproc of Symbol.sym Core.generic_name * ('TY mu_pval_aux) list (* procedure call *)


type 
'TY mu_tval =  (* (effectful) top-level values *)
   M_TVdone of 'TY mu_pval_aux (* end of top-level expression *)
 | M_TVundef of Location_ocaml.t * Undefined.undefined_behaviour (* undefined behaviour *)


type 
'TY mu_seq_expr_aux =  (* sequential (effectful) expressions with auxiliary info *)
   M_Seq_expr of Location_ocaml.t * annot list * 'TY mu_seq_expr
 | M_Seq_no_aux of 'TY mu_seq_expr (* Ott-hack for simpler typing rules *)


type 
'TY mu_memop =  (* operations involving the memory state *)
   M_PtrEq of 'TY mu_pval_aux * 'TY mu_pval_aux (* pointer equality comparison *)
 | M_PtrNe of 'TY mu_pval_aux * 'TY mu_pval_aux (* pointer inequality comparison *)
 | M_PtrLt of 'TY mu_pval_aux * 'TY mu_pval_aux (* pointer less-than comparison *)
 | M_PtrGt of 'TY mu_pval_aux * 'TY mu_pval_aux (* pointer greater-than comparison *)
 | M_PtrLe of 'TY mu_pval_aux * 'TY mu_pval_aux (* pointer less-than comparison *)
 | M_PtrGe of 'TY mu_pval_aux * 'TY mu_pval_aux (* pointer greater-than comparison *)
 | M_Ptrdiff of 'TY act * 'TY mu_pval_aux * 'TY mu_pval_aux (* pointer subtraction *)
 | M_IntFromPtr of 'TY act * 'TY act * 'TY mu_pval_aux (* cast of pointer value to integer value *)
 | M_PtrFromInt of 'TY act * 'TY act * 'TY mu_pval_aux (* cast of integer value to pointer value *)
 | M_PtrValidForDeref of 'TY act * 'TY mu_pval_aux (* dereferencing validity predicate *)
 | M_PtrWellAligned of 'TY act * 'TY mu_pval_aux
 | M_PtrArrayShift of 'TY mu_pval_aux * 'TY act * 'TY mu_pval_aux
 | M_Memcpy of 'TY mu_pval_aux * 'TY mu_pval_aux * 'TY mu_pval_aux
 | M_Memcmp of 'TY mu_pval_aux * 'TY mu_pval_aux * 'TY mu_pval_aux
 | M_Realloc of 'TY mu_pval_aux * 'TY mu_pval_aux * 'TY mu_pval_aux
 | M_Va_start of 'TY mu_pval_aux * 'TY mu_pval_aux
 | M_Va_copy of 'TY mu_pval_aux
 | M_Va_arg of 'TY mu_pval_aux * 'TY act
 | M_Va_end of 'TY mu_pval_aux


type 
'TY mu_paction =  (* memory actions with polarity *)
   M_Paction of Core.polarity * 'TY mu_action_aux


type 
'TY mu_tval_aux =  (* (effectful) top-level values with auxiliary info *)
   M_Tval of Location_ocaml.t * annot list * 'TY mu_tval
 | M_Tno_aux of 'TY mu_tval (* Ott-hack for simpler typing rules *)


type 
'TY mu_seq_texpr =  (* sequential top-level (effectful) expressions *)
   M_Seq_TEtval of 'TY mu_tval (* (effectful) top-level values *)
 | M_Seq_TErun of Symbol.sym * ('TY mu_pval_aux) list (* run from label *)
 | M_Seq_TEnd of ('TY mu_pval_aux) list (* nondeterministic choice *)
 | M_Seq_TElet of 'TY mu_sym_or_pattern * 'TY mu_seq_expr_aux * 'TY mu_texpr (* pure sequencing *)
 | M_Seq_TEcase of 'TY mu_pval_aux * ((mu_pattern_aux * 'TY mu_texpr)) list (* pattern matching *)
 | M_Seq_TEif of 'TY mu_pval_aux * 'TY mu_texpr * 'TY mu_texpr (* conditional *)
 | M_Seq_TEbound of int * 'TY mu_is_texpr_aux (* limit scope of indet seq behaviour, absent at runtime *)

and 'TY mu_seq_texpr_aux =  (* sequential top-level (effectful) expressions with auxiliary info *)
   M_Seq_Texpr of Location_ocaml.t * annot list * 'TY mu_seq_texpr
 | M_Seq_Tseq_no_aux of 'TY mu_seq_texpr (* Ott-hack for simpler typing rules *)

and 'TY mu_is_expr =  (* indet seq (effectful) expressions *)
   M_Is_Ememop of 'TY mu_memop (* pointer op involving memory *)
 | M_Is_Eaction of 'TY mu_paction (* memory action *)
 | M_Is_Eunseq of ('TY mu_texpr) list (* unsequenced expressions *)

and 'TY mu_is_expr_aux =  (* indet seq (effectful) expressions with auxiliary info *)
   M_Is_expr of Location_ocaml.t * annot list * 'TY mu_is_expr
 | M_Is_no_aux of 'TY mu_is_expr (* Ott-hack for simpler typing rules *)

and 'TY mu_is_texpr =  (* indet seq top-level (effectful) expressions *)
   M_is_TEwseq of mu_pattern_aux * 'TY mu_is_expr_aux (* weak sequencing *)
 | M_is_TEsseq of 'TY mu_sym_or_pattern * 'TY mu_is_expr_aux (* strong sequencing *)

and 'TY mu_is_texpr_aux =  (* indet seq top-level (effectful) expressions with auxiliary info *)
   M_Is_Texpr of Location_ocaml.t * annot list * 'TY mu_is_texpr
 | M_Is_Tno_aux of 'TY mu_is_texpr (* Ott-hack for simpler typing rules *)

and 'TY mu_texpr =  (* top-level (effectful) expressions *)
   M_TESeq of 'TY mu_seq_texpr_aux (* sequential (effectful) expressions *)
 | M_TENs of 'TY mu_is_texpr_aux (* indet seq (effectful) expressions *)


type 
'bt bool_op = 
   Not of 'bt term_aux
 | Eq of 'bt term_aux * 'bt term_aux
 | And of ('bt term_aux) list

and 'bt arith_op = 
   Mul of 'bt term_aux * 'bt term_aux

and 'bt list_op = 
   Nil
 | Cons of 'bt term_aux * 'bt term_aux
 | Tail of 'bt term_aux
 | List of ('bt term_aux) list
 | NthList of int * 'bt term_aux

and 'bt tuple_op = 
   Tuple of ('bt term_aux) list
 | NthTuple of 'bt term_aux * int

and 'bt pointer_op = 
   Null of Impl_mem.pointer_value
 | AddPointer of 'bt term_aux * 'bt term_aux

and 'bt option_op = 
   Nothing of BT.t
 | Something of 'bt term_aux

and 'bt array_op = 
   ArrayGet of 'bt term_aux * 'bt term_aux

and 'bt param_op = 
   App of 'bt term_aux * ('bt term_aux) list

and 'bt struct_op = 
   StructMember of tag * 'bt term_aux * Symbol.identifier

and 'bt ct_pred = 
   Representable of Sctypes.t * 'bt term_aux
 | AlignedI of 'bt term_aux * 'bt term_aux

and 'bt term = 
   Lit of lit
 | Arith_op of 'bt arith_op
 | Bool_op of 'bt bool_op
 | Tuple_op of 'bt tuple_op
 | Struct_op of 'bt struct_op
 | Pointer_op of 'bt pointer_op
 | List_op of 'bt list_op
 | Array_op of 'bt array_op
 | CT_pred of 'bt ct_pred
 | Option_op of 'bt option_op
 | Param_op of 'bt param_op

and 'bt term_aux =  (* terms with auxiliary info *)
   IT of 'bt term * 'bt
 | IT_no_aux of 'bt term (* Ott-hack for simpler typing rules *)


type 
predicate_name =  (* names of predicates *)
   Ctype of Sctypes.t (* C type *)
 | Id of string (* arbitrary *)


type 
resource = 
   Predicate of type predicate = { name : predicate_name; pointer: IT.t; iargs: IT.t list; oargs: IT.t list; init: bool; perm : int * int; }


type 
ret =  (* return types *)
   RetTy_Computational of 'sym * base_type * ret
 | RetTy_Logical of 'sym * base_type * ret
 | RetTy_Resource of resource * ret
 | RetTy_Constraint of 'bt term_aux * ret
 | RetTy_I


type 
arg =  (* argument types *)
   ArgTy_Computational of 'sym * base_type * arg
 | ArgTy_Logical of 'sym * base_type * arg
 | ArgTy_Resource of resource * arg
 | ArgTy_Constraint of 'bt term_aux * arg
 | ArgTy_I

(** definitions *)
(** definitions *)
(** definitions *)
(** definitions *)
(** definitions *)
(** definitions *)
(** definitions *)


