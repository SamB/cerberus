(* generated by Ott 0.31 from: mucore.ott *)


type 
base_type =  (* Core base types *)
   BTy_Unit (* unit *)
 | BTy_Bool of bool (* boolean *)
 | BTy_Integer (* integer *)
 | BTy_Read (* rational numbers? *)
 | BTy_Loc (* location *)
 | BTy_List of base_type (* list *)
 | BTy_Tuple of (base_type) list (* tuple *)
 | BTy_Struct of tag
 | BTy_Set of base_type (* set *)
 | BTy_Option of base_type (* option *)
 | BTy_Param of (base_type) list * base_type (* parameter types *)


type 
'TY mu_object_value =  (* C object values *)
   M_OVinteger of Cerb_frontend.Impl_mem.integer_value (* integer value *)
 | M_OVpointer of Cerb_frontend.Impl_mem.pointer_value (* pointer value *)
 | M_OVarray of ('TY mu_loaded_value) list (* C array value *)
 | M_OVstruct of tag * ((Symbol.identifier * T.ct * Impl_mem.mem_value)) list (* C struct value *)
 | M_OVunion of tag * Symbol.identifier * Impl_mem.mem_value (* C union value *)

and 'TY mu_loaded_value =  (* potentially unspecified C object values *)
   M_LVspecified of 'TY mu_object_value (* non-unspecified loaded value *)


type 
'TY mu_value =  (* Core values *)
   M_Vobject of 'TY mu_object_value (* C object value *)
 | M_Vloaded of 'TY mu_loaded_value (* loaded C object value *)
 | M_Vunit
 | M_Vtrue
 | M_Vfalse
 | M_Vlist of T.bt * ('TY mu_value) list
 | M_Vtuple of ('TY mu_value) list (* tuple *)


type 
'bty mu_ctor =  (* data constructors *)
   M_Cnil of T.bt (* empty list *)
 | M_Ccons (* list cons *)
 | M_Ctuple (* tuple *)
 | M_Carray (* C array *)
 | M_Civmax (* max integer value *)
 | M_Civmin (* min integer value *)
 | M_Civsizeof (* sizeof value *)
 | M_Civalignof (* alignof value *)
 | M_CivCOMPL (* bitwise complement *)
 | M_CivAND (* bitwise AND *)
 | M_CivOR (* bitwise OR *)
 | M_CivXOR (* bitwise XOR *)
 | M_Cspecified (* non-unspecified loaded value *)
 | M_Cunspecified (* unspecified loaded value *)
 | M_Cfvfromint (* cast integer to floating value *)
 | M_Civfromfloat (* cast floating to integer value *)


type 
mu_pattern_aux = 
   M_CaseBase of ( Symbol.sym option * T.bt )
 | M_CaseCtor of 'bty mu_ctor * (mu_pattern) list

and mu_pattern = 
   M_Pattern of Location_ocaml.t * annot list * mu_pattern_aux


type 
'TY mu_sym_or_pattern = 
   M_Symbol of Symbol.sym
 | M_Pat of mu_pattern


type 
'TY mu_pexpr_aux =  (* Core pure expressions *)
   M_PEsym of Symbol.sym
 | M_PEimpl (* implementation-defined constant *)
 | M_PEval of 'TY mu_value
 | M_PEconstrained of ((Mem.mem_iv_constraint * 'TY asym)) list (* constrained value *)
 | M_PEundef of Location_ocaml.t * Undefined.undefined_behaviour (* undefined behaviour *)
 | M_PEerror of string * 'TY asym (* impl-defined static error *)
 | M_PEctor of 'bty mu_ctor * ('TY asym) list (* data constructor application *)
 | M_PEarray_shift of 'TY asym * T.ct * 'TY asym (* pointer array shift *)
 | M_PEmember_shift of 'TY asym * Symbol.sym * Symbol.identifier (* pointer struct/union member shift *)
 | M_PEnot of 'TY asym (* boolean not *)
 | M_PEop of Core.binop * 'TY asym * 'TY asym
 | M_PEstruct of Symbol.sym * ((Symbol.identifier * 'TY asym)) list (* C struct expression *)
 | M_PEunion of Symbol.sym * Symbol.identifier * 'TY asym (* C union expression *)
 | M_PEmemberof of Symbol.sym * Symbol.identifier * 'TY asym (* C struct/union member access *)
 | M_PEcall of Symbol.sym Core.generic_name * ('TY asym) list (* pure function call *)
 | M_PEassert_undef of 'TY asym * Location_ocaml.t * Undefined.undefined_behaviour
 | M_PEbool_to_integer of 'TY asym
 | M_PEconv_int of T.ct * 'TY asym
 | M_PEwrapI of T.ct * 'TY asym


type 
'TY mu_pexpr = 
   Pexpr of Location_ocaml.t * 'TY * 'TY mu_pexpr_aux * 'TY mu_pexpr_aux


type 
('bty, 'sym) mu_tpexpr_aux =  (* Core top-level pure expressions *)
   PEcase of 'TY asym * (mu_pattern) list (* pattern matching *)
 | PElet of 'TY mu_sym_or_pattern (* pure let *)
 | PEif of 'TY asym (* pure if *)
 | PEdone of 'TY asym (* pure done *)


type 
('bty, 'sym) mu_action_aux =  (* memory actions *)
   Create of 'TY mu_pexpr * 'TY mu_pexpr * symbol_prefix
 | CreateReadOnly of 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * symbol_prefix
 | Alloc of 'TY mu_pexpr * 'TY mu_pexpr * symbol_prefix
 | Kill of bool * 'TY mu_pexpr (* the boolean indicates whether the action is dynamic (i.e. free()) *)
 | Store of bool * 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * cmm_memory_order (* the boolean indicates whether the store is locking *)
 | Load of 'TY mu_pexpr * 'TY mu_pexpr * cmm_memory_order
 | RMW of 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * cmm_memory_order * cmm_memory_order
 | Fence of cmm_memory_order
 | CompareExchangeStrong of 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * cmm_memory_order * cmm_memory_order
 | CompareExchangeWeak of 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * cmm_memory_order * cmm_memory_order
 | LinuxFence of linux_linux_memory_order
 | LinuxLoad of 'TY mu_pexpr * 'TY mu_pexpr * linux_linux_memory_order
 | LinuxStore of 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * linux_linux_memory_order
 | LinuxRMW of 'TY mu_pexpr * 'TY mu_pexpr * 'TY mu_pexpr * linux_linux_memory_order


type 
('a, 'bty, 'sym) mu_action = 
   Action of Location_ocaml.t * a * ('bty, 'sym) mu_action_aux


type 
('a, 'bty, 'sym) mu_paction =  (* memory actions with polarity *)
   Paction of Core.polarity * ('a, 'bty, 'sym) mu_action


type 
('a, 'bty, 'sym) mu_expr_aux =  (* (effectful) expression *)
   Epure of 'TY mu_pexpr
 | Ememop of mem_memop * ('TY mu_pexpr) list (* pointer op involving memory *)
 | Eaction of ('a, 'bty, 'sym) mu_paction (* memory action *)
 | Ecase of 'TY mu_pexpr * ((mu_pattern * ('a, 'bty, 'sym) mu_expr)) list (* pattern matching *)
 | Elet of mu_pattern * 'TY mu_pexpr * ('a, 'bty, 'sym) mu_expr
 | Eif of 'TY mu_pexpr * ('a, 'bty, 'sym) mu_expr * ('a, 'bty, 'sym) mu_expr
 | Eskip
 | Eccall of a * 'TY mu_pexpr * 'TY mu_pexpr * ('TY mu_pexpr) list (* C function call *)
 | Eproc of a * Symbol.sym Core.generic_name * ('TY mu_pexpr) list (* Core procedure call *)
 | Eunseq of (('a, 'bty, 'sym) mu_expr) list (* unsequenced expressions *)
 | Ewseq of mu_pattern * ('a, 'bty, 'sym) mu_expr * ('a, 'bty, 'sym) mu_expr (* weak sequencing *)
 | Esseq of mu_pattern * ('a, 'bty, 'sym) mu_expr * ('a, 'bty, 'sym) mu_expr (* strong sequencing *)
 | Easeq of code_sym_base_type_pair * ('a, 'bty, 'sym) mu_action * ('a, 'bty, 'sym) mu_paction (* atomic sequencing *)
 | Eindet of nat * ('a, 'bty, 'sym) mu_expr (* indeterminately sequenced expr *)
 | Ebound of nat * ('a, 'bty, 'sym) mu_expr (* $\ldots$and boundary *)
 | End of (('a, 'bty, 'sym) mu_expr) list (* nondeterministic sequencing *)
 | Esave of code_sym_base_type_pair * (base_type_pexpr_pair) list * ('a, 'bty, 'sym) mu_expr (* save label *)
 | Erun of a * ('TY mu_pexpr) list (* run from label *)
 | Epar of (('a, 'bty, 'sym) mu_expr) list (* cppmem-like thread creation *)
 | Ewait of thread_thread_id (* wait for thread termination *)

and ('a, 'bty, 'sym) mu_expr = 
   Expr of annot list * ('a, 'bty, 'sym) mu_expr_aux


type 
'bt pointer_op = 
   Null


type 
lit = 
   Lit_Sym of x
 | Lit_Unit
 | Lit_Bool of bool
 | Lit_Z of Z.t
 | Lit_Pointer of Z.t


type 
'bt bool_op = 
   Not of 'bt index_term
 | Eq of 'bt index_term * 'bt index_term
 | And of ('bt index_term) list

and 'bt list_op = 
   List of ('bt index_term) list
 | NthList of 'bt index_term * int

and 'bt param_op = 
   App of 'bt index_term * ('bt index_term) list

and 'bt index_term_aux = 
   Bool_op of 'bt bool_op
 | List_op of 'bt list_op
 | Pointer_op of 'bt pointer_op
 | Param_op of 'bt param_op

and 'bt index_term = 
   Lit of lit
 | IT of 'bt index_term_aux * 'bt


type 
n =  (* constraints env *)
   Con_empty
 | Con_cons of n


type 
ret =  (* return types *)
   RetTy_Computational of x * base_type * ret
 | RetTy_Logical of x * ret
 | RetTy_Resource of ret
 | RetTy_Constraint of 'bt index_term * ret
 | RetTy_I


type 
l =  (* logical var env *)
   Log_empty
 | Log_cons of l * x


type 
c =  (* computational var env *)
   Comp_empty
 | Comp_cons of c * x * base_type


type 
'bt tuple_op = 
   Tuple of ('bt index_term) list
 | NthTuple of 'bt index_term * int


type 
arg =  (* argument types *)
   ArgTy_Computational of x * base_type * arg
 | ArgTy_Logical of x * arg
 | ArgTy_Resource of arg
 | ArgTy_Constraint of 'bt index_term * arg
 | ArgTy_I

(** definitions *)


