% Categories
% X - hide from Tex
% O - hide from OCaml

embed {{ tex-preamble
\geometry{landscape}
\renewcommand{\[[TEX_NAME_PREFIX]]kw}[1]{ \texttt{#1} }
\renewcommand{\[[TEX_NAME_PREFIX]]drule}[4][]{ {\displaystyle\frac{\begin{array}{l}#2\end{array} }{#3}\quad\[[TEX_NAME_PREFIX]]drulename{#4} }\\[\baselineskip] }
}}

metavar ident , x , y , yp {{ tex y_p }} , _ ::= {{ phantom }}
  {{ com subscript p is for pointers }}

grammar

  Sctypes_t , ct {{ tex \tau }} :: '' ::= {{ ocaml Sctypes.t }} {{ phantom }} {{ com C type }}
    | ct ast :: :: Pointer {{ com pointer to type $[[ct]]$ }} {{ tex [[ct]] { [[ast]] } }}


grammar

  ty_tag {{ tex tag }} :: 'Ty_tag' ::= {{ ocaml tag }} {{ phantom }} {{ com OCaml type for struct/union tag }}
    | ident :: :: ident

  base_type {{ tex \beta }} , _bt {{ tex \_ }} :: '' ::= {{ com base types }}
    | unit                                      ::   :: Unit    {{ com unit              }}
    | bool                                      ::   :: Bool    {{ com boolean           }}
    | integer                                   ::   :: Integer {{ com integer           }}
    | real                                      ::   :: Read    {{ com rational numbers? }}
    | loc                                       ::   :: Loc     {{ com location          }}
    | array base_type                           ::   :: Array   {{ com array             }}
    | [ base_type ]                             ::   :: ListTy  {{ com list              }}
    | base_type1 * .. * base_typen              ::   :: TupleTy {{ com tuple             }}
    | struct ty_tag                             ::   :: Struct  {{ com struct            }}
    | { base_type }                             ::   :: Set     {{ com set               }}
    | opt ( base_type )                         ::   :: Option  {{ com option            }}
    % ASK Delete this type? Would complicate spine judgement if remains
    | base_type1 , .. , base_typen -> base_type ::   :: Param   {{ com parameter types   }}
    | to_base ( ct )                            :: M :: Of_Ctype {{ com of a C type      }}
                                                                 {{ tex \mathrm{of\_ctype}( [[ct]] ) }} 
                                                                 {{ ocaml (BT.of_sct ( [[ct]] ) ) }}

grammar

  % Binary operators
  binop :: 'Op' ::= {{ ocaml Core.binop }} {{ phantom }} {{ com binary operators }}
    % arithmetic operators (integer -> integer -> integer)
    | +     :: :: Add   {{ tex \texttt{+}         }} {{ com addition       }}
    | -     :: :: Sub   {{ tex \texttt{-}         }} {{ com subtraction    }}
    | *     :: :: Mul   {{ tex \texttt{*}         }} {{ com multiplication }}
    | /     :: :: Div   {{ tex \texttt{/}         }} {{ com division       }}
    | rem_t :: :: Rem_t                              {{ com modulus        }}
    | rem_f :: :: Rem_f                              {{ com remainder      }}
    | ^     :: :: Exp   {{ tex \texttt{\char`^}   }} {{ com exponentiation }}
    % relational operators ( integer -> integer -> bool)
    | =     :: :: Eq    {{ tex \texttt{=}         }} {{ com equality, defined both for integer and C types }}
    | >     :: :: Gt    {{ tex \texttt{>}         }} {{ com greater than                                   }}
    | <     :: :: Lt    {{ tex \texttt{<}         }} {{ com less than                                      }}
    | >=    :: :: Ge    {{ tex \texttt{>=}        }} {{ com greater than or equal to                       }}
    | <=    :: :: Le    {{ tex \texttt{<=}        }} {{ com less than or equal to                          }}
    % logical connectives ( bool -> bool -> bool)
    | /\    :: :: And   {{ tex \texttt{/\char`\\} }} {{ com conjucntion }}
    | \/    :: :: Or    {{ tex \texttt{\char`\\/} }} {{ com disjunction }}


metavar impl_const ::= {{ ocaml Implementation.implementation_constant }} {{ phantom }}
  {{ com implementation-defined constant }}

grammar

  tyvar_sym {{ tex ident }}:: 'Tyvar_sym_' ::= {{ ocaml 'sym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ident :: :: ident

metavar ty_mem_int {{ tex mem\_int }} ::= {{ ocaml Impl_mem.integer_value }} {{ phantom }}
  {{ com memory integer value }}

metavar Symbol_identifier {{ tex member }} ::= {{ ocaml Symbol.identifier }} {{ phantom }}
  {{ com C struct/union member name }}

metavar annots {{ tex }} ::= {{ ocaml annot list }} {{ phantom }}
  {{ com Ott-hack, ignore (annotations) }}

metavar ty_nat {{ tex nat }} ::= {{ ocaml Nat_big_num.num }} {{ phantom }}
  {{ com OCaml arbitrary-width natural number }}

indexvar n, i ::= {{ phantom }} {{ com index variables }}

metavar ty_mem_ptr {{ tex mem\_ptr }} ::= {{ ocaml Impl_mem.pointer_value }} {{ phantom }}
    {{ com abstract pointer value }}

%   ty_mem_ptr {{ tex mem\_ptr }} :: 'PV' ::= {{ ocaml Impl_mem.pointer_value }} {{ phantom }} {{ com pointer values }}
%     | nullptr            :: :: null       {{ com null pointer }}
%     | funcptr Symbol_sym :: :: function   {{ com function pointer }}
%     | concptr ty_nat     :: :: concrete   {{ com concrete pointer }}

metavar ty_mem_value {{ tex mem\_val }} ::= {{ phantom }} {{ ocaml Impl_mem.mem_value }}
    {{ com abstract memory value }}

% ty_mem_value {{ tex mem\_val }} :: 'MV' ::= {{ phantom }} {{ ocaml Impl_mem.mem_value }} {{ com memory value }}
%     | int ty_mem_int                                                                 :: :: integer
%     | ty_mem_ptr                                                                     :: :: pointer
%     | array ( </ ty_mem_valuei // i /> )                                             :: :: array
%     | ( struct Symbol_sym ) { </ . Symbol_identifieri = ty_mem_valuei // , // i /> } :: :: struct
%     | union Symbol_sym Symbol_identifier                                             :: :: union


grammar

  T_ct {{ tex \tau }} :: 'T_ct_of_' ::= {{ ocaml T.ct }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ct :: :: ct

grammar

  Symbol_sym {{ tex ident }}:: '' ::= {{ ocaml Symbol.sym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ident  :: :: ident
    | ty_tag :: :: ty_tag {{ com hack for struct typing rules }}


grammar

  mu_object_value {{ tex object\_value }} :: 'M_OV' ::=  {{ auxparam 'TY }} {{ com C object values (inhabitants of object types), which can be read/stored }}
    | ty_mem_int                                                                                :: :: integer {{ com integer value  }}
    | ty_mem_ptr                                                                                :: :: pointer {{ com pointer value  }}
    | array ( </ mu_loaded_valuei // , // i /> )                                                :: :: array   {{ com C array value  }}
    | ( struct Symbol_sym ) { </ dot Symbol_identifieri : T_cti = ty_mem_valuei // , // i /> }  :: :: struct  {{ com C struct value }}
    | ( union Symbol_sym ) { dot Symbol_identifier = ty_mem_value }                             :: :: union   {{ com C union value  }}


  smt_object_value :: 'SMT_OV' ::=  {{ auxparam 'TY }} {{ com like above, but can be embeded into the SMT value grammar }}
    | ty_mem_int                                                                                :: :: integer {{ com integer value  }}
    | ty_mem_ptr                                                                                :: :: pointer {{ com pointer value  }}
    | ( struct Symbol_sym ) { </ dot Symbol_identifieri : T_cti = ty_mem_valuei // , // i /> }  :: :: struct  {{ com C struct value }}
    | ( union Symbol_sym ) { dot Symbol_identifier = ty_mem_value }                             :: :: union   {{ com C union value  }}


  mu_loaded_value {{ tex loaded\_value }} :: 'M_LV' ::= {{ auxparam 'TY }} {{ com potentially unspecified C object values }}
    | specified mu_object_value :: :: specified {{ com specified loaded value }}


  smt_loaded_value :: 'SMT_LV' ::= {{ auxparam 'TY }} {{ com like above, but can be embeded into SMT value grammar }}
    | specified smt_object_value :: :: specified {{ com specified loaded value }}


  subrules
    smt_object_value <:: mu_object_value
    smt_loaded_value <:: mu_loaded_value


grammar

  T_bt {{ tex \beta }} :: 'T_bt_' ::= {{ ocaml T.bt }} {{ phantom }} {{ com Ott-hack, ignore }}
    | base_type :: :: BaseType


grammar

  mu_value {{ tex value }} :: 'M_V' ::= {{ auxparam 'TY }} {{ com Core values }}
    | mu_object_value                    :: :: object {{ com C object value        }}
    | mu_loaded_value                    :: :: loaded {{ com loaded C object value }}
    | Unit                               :: :: unit   {{ com unit                  }}
    | True                               :: :: true   {{ com boolean true          }}
    | False                              :: :: false  {{ com boolean false         }}
    | T_bt [ </ mu_valuei // , // i /> ] :: :: list   {{ com list                  }}
    | ( </ mu_valuei // , // i /> )      :: :: tuple  {{ com tuple                 }}


  smt_value :: 'SMT_V' ::= {{ auxparam 'TY }} {{ com like above, but can be embeded into SMT value grammar }}
    | smt_object_value                    :: :: object {{ com C object value        }}
    | smt_loaded_value                    :: :: loaded {{ com loaded C object value }}
    | Unit                                      :: :: unit   {{ com unit                  }}
    | True                                      :: :: true   {{ com boolean true          }}
    | False                                     :: :: false  {{ com boolean false         }}
    | T_bt [ </ smt_valuei // , // i /> ] :: :: list   {{ com list                  }}
    | ( </ smt_valuei // , // i /> )      :: :: tuple  {{ com tuple                 }}


  subrules
    smt_value <:: mu_value


grammar

  mu_ctor_val {{ tex ctor\_val }} :: 'M_C' ::= {{ com data constructors }}
    | Nil T_bt    :: :: nil         {{ com empty list                     }} % : [bTy]
    | Cons        :: :: cons        {{ com list cons                      }} % : bTy -> [bTy] -> [bTy]
    | Tuple       :: :: tuple       {{ com tuple                          }} % : bTy1 -> ... -> bTyN -> (bTy1, ..., bTyN)
    | Array       :: :: array       {{ com C array                        }} % : bTy -> ... -> bTy -> array bTy
    | Specified   :: :: specified   {{ com non-unspecified loaded value   }} % : objTy -> loaded objTy


  smt_ctor_val :: 'SMT_C' ::= {{ com like above, but can be embeded into SMT value grammar }}
    | Nil T_bt    :: :: nil         {{ com empty list                     }} % : [bTy]
    | Cons        :: :: cons        {{ com list cons                      }} % : bTy -> [bTy] -> [bTy]
    | Tuple       :: :: tuple       {{ com tuple                          }} % : bTy1 -> ... -> bTyN -> (bTy1, ..., bTyN)
    | Specified   :: :: specified   {{ com non-unspecified loaded value   }} % : objTy -> loaded objTy


  mu_ctor_expr {{ tex ctor\_expr }} :: 'M_C' ::= {{ com data constructors }}
    | Ivmax       :: :: ivmax       {{ com max integer value              }} % : ctype -> integer
    | Ivmin       :: :: ivmin       {{ com min integer value              }} % : ctype -> integer
    | Ivsizeof    :: :: ivsizeof    {{ com sizeof value                   }} % : ctype -> integer
    | Ivalignof   :: :: ivalignof   {{ com alignof value                  }} % : ctype -> integer
    | IvCOMPL     :: :: ivCOMPL     {{ com bitwise complement             }} % : ctype -> integer -> integer
    | IvAND       :: :: ivAND       {{ com bitwise AND                    }} % : ctype -> integer -> integer -> integer
    | IvOR        :: :: ivOR        {{ com bitwise OR                     }} % : ctype -> integer -> integer -> integer
    | IvXOR       :: :: ivXOR       {{ com bitwise XOR                    }} % : ctype -> integer -> integer -> integer
    | Fvfromint   :: :: fvfromint   {{ com cast integer to floating value }} % : integer -> floating
    | Ivfromfloat :: :: ivfromfloat {{ com cast floating to integer value }} % : ctype -> floating -> integer


  subrules
    smt_ctor_val <:: mu_ctor_val


metavar ty_loc {{ tex }} ::= {{ ocaml Location_ocaml.t }} {{ phantom }}
  {{ com Ott-hack, ignore (locations) }}

metavar Mem_mem_iv_constraint {{ tex mem\_iv\_c }} ::= {{ ocaml Mem.mem_iv_constraint }} {{ phantom }}
  {{ com OCaml type for memory constraints on integer values }}

metavar UB_name ::= {{ ocaml Undefined.undefined_behaviour }} {{ phantom }}
 {{ com undefined behaviour }}

metavar ty_string {{ tex string }} ::= {{ ocaml string }} {{ phantom }}
  {{ com OCaml string }}

metavar tyvar_TY {{ tex }} ::= {{ ocaml 'TY }} {{ phantom }}
  {{ com Ott-hack, ignore (OCaml type variable TY) }}


grammar

  ty_act {{ tex \tau }} :: 'Ty_act_of' ::= {{ ocaml 'TY act }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ct :: :: ct


grammar

  mu_name {{ tex name }} :: '' ::= {{ ocaml Symbol.sym Core.generic_name }} {{ phantom }}
    | Symbol_sym :: :: Sym  {{ com Core identifier                 }}
    | impl_const :: :: Impl {{ com implementation-defined constant }}


grammar

  mu_pval {{ tex pval }} :: 'M_PV' ::= {{ auxparam 'TY }} {{ com pure values }}
    | Symbol_sym                                                                      :: :: sym          {{ com Core identifier                           }}
    | impl_const                                                                      :: :: impl         {{ com implementation-defined constant           }}
    | mu_value                                                                        :: :: mu_val       {{ com Core values                               }}
    | constrained ( </ Mem_mem_iv_constrainti , mu_pval_auxi // , // i /> )           :: :: constrained  {{ com constrained value                         }}
    | error ( ty_string , mu_pval_aux )                                               :: :: error        {{ com impl-defined static error                 }}
    | mu_ctor_val ( </ mu_pval_auxi // , // i /> )                                    :: :: ctor         {{ com data constructor application              }}
    | ( struct Symbol_sym ) { </ dot Symbol_identifieri = mu_pval_auxi // , // i /> } :: :: struct       {{ com C struct expression                       }}
    | ( union Symbol_sym ) { dot Symbol_identifier = mu_pval_aux }                    :: :: union        {{ com C union expression                        }}


  smt_pval :: 'SMT_PV' ::= {{ auxparam 'TY }} {{ com like above, but can be embeded into SMT value grammar }}
    | Symbol_sym                                                                       :: :: sym          {{ com Core identifier                           }}
    | impl_const                                                                       :: :: impl         {{ com implementation-defined constant           }}
    | smt_value                                                                        :: :: em_val       {{ com Core values                               }}
    | constrained ( </ Mem_mem_iv_constrainti , smt_pval_auxi // , // i /> )           :: :: constrained  {{ com constrained value                         }}
    | error ( ty_string , smt_pval_aux )                                               :: :: error        {{ com impl-defined static error                 }}
    | smt_ctor_val ( </ smt_pval_auxi // , // i /> )                                   :: :: ctor         {{ com data constructor application              }}
    | ( struct Symbol_sym ) { </ dot Symbol_identifieri = smt_pval_auxi // , // i /> } :: :: struct       {{ com C struct expression                       }}
    | ( union Symbol_sym ) { dot Symbol_identifier = smt_pval_aux }                    :: :: union        {{ com C union expression                        }}


  mu_pval_aux {{ tex pval }} :: 'M_P' ::= {{ auxparam 'TY }} {{ com pure values with auxiliary info }}
    | ty_loc annots tyvar_TY mu_pval :: X :: val
    |                        mu_pval :: O :: val_no_aux {{ com Ott-hack for simpler typing rules }}


  smt_pval_aux {{ tex smt\_pval }} :: 'SMT_P' ::= {{ auxparam 'TY }} {{ com like above, but can be embeded into SMT value grammar }}
    | smt_pval :: O :: val_no_aux {{ com Ott-hack for simpler typing rules }}


  subrules
    mu_name <:: mu_pval
    smt_pval <:: mu_pval
    smt_pval_aux <:: mu_pval_aux


grammar

  mu_pexpr {{ tex pexpr }} :: 'M_PE' ::= {{ auxparam 'TY }} {{ com pure expressions }}
    | mu_pval_aux                                                   :: :: pval         {{ com pure values                               }}
    | mu_ctor_expr ( </ mu_pval_auxi // , // i /> )                 :: :: ctor         {{ com data constructor application              }}
    | array_shift ( mu_pval_aux1 , T_ct , mu_pval_aux2 )            :: :: array_shift  {{ com pointer array shift                       }}
    | member_shift ( mu_pval_aux , Symbol_sym , Symbol_identifier ) :: :: member_shift {{ com pointer struct/union member shift         }}
    | not ( mu_pval_aux )                                           :: :: not          {{ com boolean not                               }}
    | mu_pval_aux1 binop mu_pval_aux2                               :: :: op           {{ order [[binop]] [[mu_pval_aux1]] [[mu_pval_aux2]] }} {{ com binary operations }}
    | memberof  ( Symbol_sym , Symbol_identifier , mu_pval_aux )    :: :: memberof     {{ com C struct/union member access              }}
    | mu_name ( mu_pval_aux1 , .. , mu_pval_auxn )                  :: :: call         {{ com pure function call                        }}

    | assert_undef ( mu_pval_aux , ty_loc UB_name )                 :: :: assert_undef
    | bool_to_integer ( mu_pval_aux )                               :: :: bool_to_integer
    | conv_int ( ty_act , mu_pval_aux )                             :: :: conv_int
    | wrapI ( ty_act , mu_pval_aux )                                :: :: wrapI


  mu_pexpr_aux {{ tex pexpr }} :: 'M_P' ::= {{ auxparam 'TY }} {{ com pure expressions with location and annotations }}
    | ty_loc annots tyvar_TY mu_pexpr :: X :: expr
    |                        mu_pexpr :: O :: expr_no_aux {{ com Ott-hack for simpler typing rules }}


grammar

  mu_tpval {{ tex tpval }} :: 'M_TPV' ::= {{ auxparam 'TY }} {{ com top-level pure values }}
    | undef ty_loc UB_name :: :: undef {{ com undefined behaviour }}
    | done mu_pval_aux     :: :: done  {{ com pure done           }}


  mu_tpval_aux {{ tex tpval }} :: 'M_TP' ::= {{ auxparam 'TY }} {{ com top-level pure values with location and annotations }}
    | ty_loc annots tyvar_TY mu_tpval :: X :: val
    |                        mu_tpval :: O :: val_no_aux   {{ com Ott-hack for simpler typing rules }}


grammar

  ty_sym_opt_T_bt {{ tex ident\_opt\_\beta }} :: '' ::= {{ ocaml ( Symbol.sym option * T.bt ) }} {{ phantom }}
                                                        {{ com type annotated optional identifier }}
    | _ : T_bt          :: :: No_sym % (+ binders = {} +)
    | Symbol_sym : T_bt :: :: Just   % (+ binders = Symbol_sym +)


grammar

  mu_pattern {{ tex pattern }} :: 'M_Case' ::=
    | ty_sym_opt_T_bt                                 :: :: Base % (+ binders = binders( maybesym_base_type ) +)
    | mu_ctor_val ( </ mu_pattern_auxi // , // i /> ) :: :: Ctor % (+ binders = binders( </ mu_pattern_auxi // , // i /> ) +)


  mu_pattern_aux {{ tex pattern }} :: 'M_' ::=
    | ty_loc annots mu_pattern :: X :: Pattern                                                % (+ binders = binders(mu_pattern) +)
    |               mu_pattern :: O :: Pat_no_aux {{ com Ott-hack for simpler typing rules }} % (+ binders = binders(mu_pattern) +)


grammar

  mu_sym_or_pattern {{ tex ident\_or\_pattern }} :: 'M_' ::= {{ auxparam 'TY }}
    | Symbol_sym     :: :: Symbol % (+ binders = Symbol_sym +)
    | mu_pattern_aux :: :: Pat    % (+ binders = binders(mu_pattern_aux) +)


grammar

  mu_tpexpr {{ tex tpexpr }} :: 'M_TPE' ::= {{ auxparam 'TY }} {{ com top-level pure expressions }}
    | mu_tpval_aux                                                           ::   :: tpval {{ com top-level pure values }}
    | case mu_pval_aux of </ | mu_pattern_auxi => mu_tpexpr_auxi // i /> end ::   :: case  {{ com pattern matching      }} % TODO: binding
    | let mu_sym_or_pattern = mu_pexpr_aux in mu_tpexpr_aux                  ::   :: let   {{ com pure let              }} % TODO: binding
    | if mu_pval_aux then mu_tpexpr_aux1 else mu_tpexpr_aux2                 ::   :: if    {{ com pure if               }}
    | [ C / C' ] mu_tpexpr                                                   :: M :: contextSub {{ ocaml MU_TPEXPR_CONTEXT_SUB }}
                                                                                     {{ com simul-sub all vars in $[[C]]$ for all vars in $[[C']]$ in $[[mu_tpexpr]]$ }}


  mu_tpexpr_aux {{ tex tpexpr }} :: 'M_TP' ::= {{ auxparam 'TY }} {{ com pure top-level pure expressions with auxiliary info }}
    | ty_loc annots tyvar_TY mu_tpexpr :: X :: expr
    |                        mu_tpexpr :: O :: expr_no_aux   {{ com Ott-hack for simpler typing rules }}


grammar

  m_kill_kind :: 'M_' ::=
    | dynamic     :: :: Dynamic
    | static T_ct :: :: Static


grammar

  ty_bool {{ tex bool }} , _b {{ tex \_ }} :: '' ::=   {{ ocaml bool  }} {{ phantom }} {{ com OCaml booleans }}
    | true  :: :: True  {{ ocaml true  }}
    | false :: :: False {{ ocaml false }}

  ty_int {{ tex int }} , _int {{ tex \_ }} :: 'Int_' ::=   {{ ocaml int  }} {{ phantom }} {{ com OCaml fixed-width integer }}
    | i     ::   :: IndexVar {{ com literal integer }}
    | one   :: X :: One      {{ tex 1               }}


metavar Symbol_prefix {{ tex }} ::= {{ ocaml Symbol.prefix }} {{ phantom }}
  {{ com Ott-hack, ignore (Symbol.prefix) }}

metavar Cmm_memory_order {{ tex mem\_order }} , _mem_order {{ tex \_ }} ::= {{ ocaml Cmm_csem.memory_order }} {{ phantom }}
  {{ com OCaml type for memory order }}

metavar Linux_linux_memory_order {{ tex linux\_mem\_order }} ::= {{ ocaml Linux.linux_memory_order }} {{ phantom }}
  {{ com OCaml type for Linux memory order }}

grammar

  mu_action {{ tex mem\_action }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions }}
    | create ( mu_pval_aux , ty_act ) Symbol_prefix                                                                   :: :: Create
    | create_readonly ( mu_pval_aux1 , ty_act , mu_pval_aux2 ) Symbol_prefix                                          :: :: CreateReadOnly
    | alloc ( mu_pval_aux1 , mu_pval_aux2 ) Symbol_prefix                                                             :: :: Alloc
    | kill ( m_kill_kind , mu_pval_aux )                                                                              :: :: Kill
    | store ( ty_bool , ty_act , mu_pval_aux1 , mu_pval_aux2 , Cmm_memory_order )                                     :: :: Store {{ com true means store is locking }}
    | load ( ty_act , mu_pval_aux , Cmm_memory_order )                                                                :: :: Load
    | rmw ( ty_act ,  mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 , Cmm_memory_order1 , Cmm_memory_order2 )            :: :: RMW
    | fence ( Cmm_memory_order )                                                                                      :: :: Fence
    | cmp_exch_strong ( ty_act , mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: CompareExchangeStrong
    | cmp_exch_weak ( ty_act , mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 , Cmm_memory_order1 , Cmm_memory_order2 )   :: :: CompareExchangeWeak
    | linux_fence ( Linux_linux_memory_order )                                                                        :: :: LinuxFence
    | linux_load ( ty_act , mu_pval_aux , Linux_linux_memory_order )                                                  :: :: LinuxLoad
    | linux_store ( ty_act , mu_pval_aux1 , mu_pval_aux2 , Linux_linux_memory_order )                                 :: :: LinuxStore
    | linux_rmw ( ty_act , mu_pval_aux1 , mu_pval_aux2 , Linux_linux_memory_order )                                   :: :: LinuxRMW


  mu_action_aux {{ tex mem\_action }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions with auxiliary info }}
    | ty_loc mu_action :: X :: Action
    |        mu_action :: O :: no_aux {{ com Ott-hack for simpler typing rules }}


grammar

  polarity :: '' ::= {{ ocaml Core.polarity }} {{ phantom }} {{ com polarities for memory actions }}
    | Pos :: :: Pos {{ com sequenced by \ottkw{let\ weak} and \ottkw{let\ strong} }}
    | Neg :: :: Neg {{ com only sequenced by \ottkw{let\ strong} }}


  mu_paction {{ tex pol\_mem\_action }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions with polarity }}
    | polarity mu_action_aux :: :: Paction


grammar

  mu_memop {{ tex mem\_op }} :: 'M_' ::=  {{ auxparam 'TY }} {{ com operations involving the memory state}}
    | mu_pval_aux1 == mu_pval_aux2                            :: :: PtrEq            {{ com pointer equality comparison }}
    | mu_pval_aux1 <> mu_pval_aux2                            :: :: PtrNe            {{ com pointer inequality comparison }}
    | mu_pval_aux1 < mu_pval_aux2                             :: :: PtrLt            {{ com pointer less-than comparison }}
    | mu_pval_aux1 > mu_pval_aux2                             :: :: PtrGt            {{ com pointer greater-than comparison }}
    | mu_pval_aux1 =< mu_pval_aux2                            :: :: PtrLe            {{ com pointer less-than comparison }}
    | mu_pval_aux1 >= mu_pval_aux2                            :: :: PtrGe            {{ com pointer greater-than comparison }}
    | mu_pval_aux1 - ty_act - mu_pval_aux2                    :: :: Ptrdiff          {{ order [[ty_act]] [[mu_pval_aux1]] [[mu_pval_aux2]] }} {{ com pointer subtraction }}
                                                                               {{ tex [[mu_pval_aux1]] -_{ [[ty_act]] } [[mu_pval_aux2]] }}
    | intFromPtr ( ty_act1 , ty_act2 , mu_pval_aux )          :: :: IntFromPtr       {{ com cast of pointer value to integer value }}
    | ptrFromInt ( ty_act1 , ty_act2 , mu_pval_aux )          :: :: PtrFromInt       {{ com cast of integer value to pointer value }}
    | ptrValidForDeref ( ty_act , mu_pval_aux )               :: :: PtrValidForDeref {{ com dereferencing validity predicate }}
    | ptrWellAligned ( ty_act , mu_pval_aux )                 :: :: PtrWellAligned
    | ptrArrayShift ( mu_pval_aux1 ,  ty_act , mu_pval_aux2 ) :: :: PtrArrayShift
    | memcpy ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )   :: :: Memcpy
    | memcmp ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )   :: :: Memcmp
    | realloc ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )  :: :: Realloc
    | va_start ( mu_pval_aux1 , mu_pval_aux2 )                :: :: Va_start
    | va_copy ( mu_pval_aux )                                 :: :: Va_copy
    | va_arg ( mu_pval_aux , ty_act )                         :: :: Va_arg
    | va_end ( mu_pval_aux )                                  :: :: Va_end


grammar

   mu_tval {{ tex tval }} :: 'M_TV' ::= {{ auxparam 'TY }} {{ com (effectful) top-level values }} 
    | done mu_pval_aux     :: :: done  {{ com end of top-level expression }}
    | undef ty_loc UB_name :: :: undef {{ com undefined behaviour         }}


   mu_tval_aux {{ tex tval }} :: 'M_T' ::= {{ auxparam 'TY }} {{ com (effectful) top-level values with auxiliary info }}
     | ty_loc annots mu_tval :: X :: val
     |               mu_tval :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


grammar

  % There used to be an effectful value (mu_val) `skip' - I (dcm41) removed it because it seemed redundant.
  mu_seq_expr {{ tex seq\_expr }} :: 'M_Seq_E' ::= {{ auxparam 'TY }} {{ com sequential (effectful) expressions }}
    | mu_pval_aux                                                   :: :: pval   {{ com pure values                 }}
    | ccall ( ty_act , mu_pval_aux , </ mu_pval_auxi // , // i /> ) :: :: ccall  {{ com C function call             }}
    | pcall ( mu_name , </ mu_pval_auxi // , // i /> )              :: :: proc   {{ com procedure call              }}


  mu_seq_expr_aux {{ tex seq\_expr }} :: 'M_Seq_' ::= {{ auxparam 'TY }} {{ com sequential (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_seq_expr :: X :: expr
    |               mu_seq_expr :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_seq_texpr {{ tex seq\_texpr }} :: 'M_Seq_TE' ::= {{ auxparam 'TY }} {{ com sequential top-level (effectful) expressions }}
    | mu_tval                                                             :: :: tval  {{ com (effectful) top-level values }}
    | run Symbol_sym mu_pval_aux1 , .. , mu_pval_auxn                     :: :: run   {{ com run from label               }}
    | nd ( mu_pval_aux1 , .. , mu_pval_auxn )                             :: :: nd    {{ com nondeterministic choice      }}
    | let mu_sym_or_pattern = mu_seq_expr_aux in mu_texpr                 :: :: let   {{ com pure sequencing              }} % TODO: bindings
    | case mu_pval_aux with </ | mu_pattern_auxi => mu_texpri // i /> end :: :: case  {{ com pattern matching             }} % TODO: bindings
    | if mu_pval_aux then mu_texpr1 else mu_texpr2                        :: :: if    {{ com conditional                  }}
    | bound [ ty_int ] ( mu_is_texpr_aux )                                :: :: bound {{ com limit scope of indet seq behaviour, absent at runtime }}


  mu_seq_texpr_aux {{ tex seq\_texpr }} :: 'M_Seq_T' ::= {{ auxparam 'TY }} {{ com sequential top-level (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_seq_texpr :: X :: expr
    |               mu_seq_texpr :: O :: seq_no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_is_expr {{ tex is\_expr }} :: 'M_Is_E' ::= {{ auxparam 'TY }} {{ com indet seq (effectful) expressions }}
    | memop ( mu_memop )                   :: :: memop  {{ com pointer op involving memory }}
    | mu_paction                           :: :: action {{ com memory action               }}
    % TODO: require annotation
    | unseq ( mu_texpr1 , .. , mu_texprn ) :: :: unseq {{ com unsequenced expressions }}


  mu_is_expr_aux {{ tex is\_expr }} :: 'M_Is_' ::= {{ auxparam 'TY }} {{ com indet seq (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_is_expr :: X :: expr
    |               mu_is_expr :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_is_texpr {{ tex is\_texpr }} :: 'M_is_TE' ::= {{ auxparam 'TY }} {{ com indet seq top-level (effectful) expressions }}
    | let weak mu_pattern_aux = mu_is_expr_aux in mu_texpr_aux       :: :: wseq  {{ com weak sequencing   }} % TODO: bindings
    | let strong mu_sym_or_pattern = mu_is_expr_aux in mu_texpr_aux  :: :: sseq  {{ com strong sequencing }} % TODO: bindings


  mu_is_texpr_aux {{ tex is\_texpr }} :: 'M_Is_T' ::= {{ auxparam 'TY }} {{ com indet seq top-level (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_is_texpr :: X :: expr
    |               mu_is_texpr :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_texpr {{ tex texpr }} :: 'M_TE' ::= {{ auxparam 'TY }} {{ com top-level (effectful) expressions }}
    | mu_seq_texpr_aux :: :: Seq {{ com sequential (effectful) expressions     }}
    | mu_is_texpr_aux  :: :: Ns  {{ com indet seq (effectful) expressions }}

% TODO substitutions

grammar

  terminals :: 'terminals_' ::=
    | \      :: :: lambda    {{ tex \lambda                          }}
    | -->    :: :: red       {{ tex \longrightarrow                  }}
    |  ->    :: :: arrow     {{ tex \rightarrow                      }}
    |  ~>    :: :: leadsto   {{ tex \leadsto                         }}
    |  =>    :: :: synths    {{ tex \Rightarrow                      }}
    |  <=    :: :: checks    {{ tex \Leftarrow                       }}
    | |-     :: :: turnstile {{ tex \vdash                           }}
    | inEnv  :: :: inEnv     {{ tex \in                              }}
    | pi     :: :: pi        {{ tex \Pi                              }}
    | forall :: :: forall    {{ tex \forall                          }}
    | --o    :: :: lollipop  {{ tex \multimap                        }}
    | -)     :: :: implies   {{ tex \supset                          }}
    | sigma  :: :: sigma     {{ tex \Sigma                           }}
    | exists :: :: exists    {{ tex \exists                          }}
    | *s     :: :: star      {{ tex \star                            }}
    | *      :: :: times     {{ tex \times                           }}
    | /\     :: :: and       {{ tex \wedge                           }}
    | /\\    :: :: big_and   {{ tex \bigwedge                        }}
    | neg    :: :: neg       {{ tex \neg                             }}
    | =      :: :: eq        {{ tex =                                }}
    | <>     :: :: neq       {{ tex \neq                             }}
    | =<     :: :: lte       {{ tex \leq                             }}
    | >=     :: :: gte       {{ tex \geq                             }}
    | &      :: :: ampersand {{ tex \ \&                             }}
    | cdot   :: :: cdot      {{ tex \cdot                            }}
    | |      :: :: bar       {{ tex \mid                             }}
    | +ptr   :: :: addptr    {{ tex \mathbin{ {+}_{ \mathrm{ptr} } } }}
    | |->    :: :: mapsto    {{ tex \mapsto                          }}
    | ast    :: :: ast       {{ tex \ast                             }}
    | cons   :: :: cons      {{ tex ::                               }}
    | tick   :: :: tick      {{ tex \checkmark                       }}
    | :      :: :: of_type   {{ tex {:}                              }}
    | .      :: :: such_that {{ tex . \:                             }}
    | dot    :: :: dot       {{ tex .                                }}
    | >>     :: :: chevron   {{ tex \mathbin{ {>} \! \! {>} }        }}
    | :;     :: :: doublecol {{ tex \mathbin{ {:} {:} }              }}


grammar

  Z_t {{ tex z }} :: 'Z_' ::= {{ ocaml Z.t }} {{ phantom }} {{ com OCaml arbitrary-width integer }}
    | i                     :: M :: of_index   {{ ocaml OF_INDEX [[i]]                         }}
                                               {{ com literal integer                          }}
    | of_mem_int ty_mem_int :: M :: of_mem_ptr {{ ocaml Memory.integer_value_to_num            }}
                                               {{ tex \mathrm{of\_mem\_int}( [[ty_mem_int]] )  }}
    | to_int ct             :: M :: of_Ctype   {{ ocaml z_ ( Memory.size_of_ctype ( [[ct]] ) ) }}
                                               {{ tex \mathrm{of\_ctype}( [[ct]] )             }}
                                               {{ com size of a C type                         }}
    | ptr_size              :: M :: Ptr_size   {{ ocaml Memory.size_of_pointer                 }}
                                               {{ com size of a pointer                        }}

grammar

  rational {{ tex \mathbb{Q} }} :: 'Q_' ::= {{ ocaml ( int * int ) }} {{ phantom }} {{ com OCaml type for rational numbers }}
    | one               :: X :: One {{ ocaml (1, 1) }} {{ tex 1 }}
    | ty_int1 / ty_int2 ::   :: Frac {{ ocaml ( [[ty_int1]], [[ty_int2]] ) }} {{ tex \frac{[[ty_int1]]}{[[ty_int2]]} }}

grammar

  lit :: 'Lit_' ::=
    | tyvar_sym ::   :: Sym
    | unit      ::   :: Unit
    | ty_bool   ::   :: Bool
    | Z_t       ::   :: Z
    | rational  ::   :: Q


metavar ty_bt {{ tex }} ::= {{ ocaml 'bt }} {{ phantom }}
  {{ com Ott-hack, ignore (OCaml type variable bt) }}


grammar

  bool_op :: '' ::= {{ auxparam 'bt }}
    | neg term_aux                         ::     :: Not
    | term_aux1 = term_aux2                ::     :: Eq
    | /\\ ( </ term_auxi // , // i />    ) ::     :: And
    | term_aux1 /\ term_aux2               :: X M :: And_Binary {{ ocaml And ( [ [[term_aux1]] , [[term_aux2]] ] ) }}


  arith_op :: '' ::= {{ auxparam 'bt }}
    | term_aux1 * term_aux2 :: :: Mul

  list_op :: '' ::= {{ auxparam 'bt }}
    | nil                            :: :: Nil
    | tl term_aux                    :: :: Tail
    | term_aux ^ ty_int              :: :: NthList {{ order [[ty_int]] [[term_aux]]   }}
                                                   {{ tex [[term_aux]]^{([[ty_int]])} }}

  tuple_op :: '' ::= {{ auxparam 'bt }}
    | ( </ term_auxi // , // i /> ) :: :: Tuple
    | term_aux ^ ty_int             :: :: NthTuple {{ tex [[term_aux]]^{([[ty_int]])} }}


  pointer_op :: '' ::= {{ auxparam 'bt }}
    | of_mem_ptr ty_mem_ptr     :: :: Null
    | term_aux1 +ptr term_aux2  :: :: AddPointer


  BT_t :: '' ::= {{ ocaml BT.t }} {{ phantom }} {{ com Ott-hack, ignore }}
    | base_type :: :: Base_type


  option_op :: '' ::= {{ auxparam 'bt }}
    | none BT_t     :: :: Nothing
    | some term_aux :: :: Something


  array_op :: '' ::= {{ auxparam 'bt }}
    | term_aux1 [ term_aux2 ]     :: :: ArrayGet


  param_op :: '' ::= {{ auxparam 'bt }}
    | term_aux ( term_aux1 , .. , term_auxn ) :: :: App


  struct_op :: '' ::= {{ auxparam 'bt }}
    | ty_tag term_aux dot Symbol_identifier :: :: StructMember {{ tex [[term_aux]] [[dot]] [[Symbol_identifier]] }}


  ct_pred :: '' ::= {{ auxparam 'bt }}
    | representable ( ct , term_aux )    :: :: Representable
    | alignedI ( term_aux1 , term_aux2 ) :: :: AlignedI


  term , _t {{ tex \_ }} :: '' ::= {{ auxparam 'bt }}
    | lit        :: :: Lit
    | arith_op   :: :: Arith_op
    | bool_op    :: :: Bool_op
    | tuple_op   :: :: Tuple_op
    | struct_op  :: :: Struct_op
    | pointer_op :: :: Pointer_op
    | list_op    :: :: List_op
    | array_op   :: :: Array_op
    | ct_pred    :: :: CT_pred
    | option_op  :: :: Option_op
    | param_op   :: :: Param_op

    | ( term )                     :: S :: Paren   {{ ocaml [[term]] }} {{ com parentheses }}
    | [  term1 / tyvar_sym ] term2 :: M :: Subs    {{ ocaml INDEX_TERM_SUB }} {{ com substitute $[[term1]]$ for $[[tyvar_sym]]$ in $[[term2]]$ }}
    | embed smt_pval_aux           :: M :: Of_pval {{ tex [[smt_pval_aux]] }} {{ ocaml TERM_OF_PVAL_AUX }} {{ com can be embeded into the SMT value grammar }}
    | resource                     ::   :: Of_res  % WARNING: Different from current implementation


  term_aux {{ tex term }} :: '' ::= {{ auxparam 'bt }} {{ com terms with auxiliary info }}
    | term ty_bt :: X :: IT
    | term       :: O :: IT_no_aux {{ com Ott-hack for simpler typing rules }}


  IT_t {{ tex term }}:: '' ::= {{ ocaml IT.t }} {{ phantom }} {{ com Ott-hack, ignore }}
    | term_aux :: :: term_aux


  IT_ts_ne {{ tex terms }}:: '' ::= {{ auxparam 'bt }} {{ ocaml IT.t list }} {{ phantom }} {{ com non-empty list of terms }}
    | [ IT_t1 , ... , IT_tn ] :: :: Term_list

  predicate_name :: '' ::= {{ com names of predicates }}
    | Sctypes_t :: :: Ctype {{ com C type    }}
    | ty_string :: :: Id    {{ com arbitrary }}


  init_t {{ tex init }} , _i {{ tex }} :: '' ::= {{ ocaml bool }} {{ phantom }} {{ com initialisation status }}
    | tick :: :: init   {{ ocaml true  }}                     {{ com initialised  }}
    |  *   :: :: uninit {{ ocaml false }} {{ tex { [[*]] } }} {{ com uninitalised }}


  % WARNING: Different from current type system in two ways
  % 1. It omits { unused : bool }
  % 2. It includes { init : bool }
  % 3. It includes { perm : rational }
  predicate :: '' ::= {{ ocaml type predicate = { name : predicate_name; pointer: IT.t; iargs: IT.t list; oargs: IT.t list; init: bool; perm : int * int; } }}
                      {{ phantom }} {{ com arbitrary predicate }}
    | IT_ts_ne1 ( rational )|- init_t - predicate_name -> IT_ts_ne2 :: :: Predicate_def
      {{ tex [[IT_ts_ne1]] \mathbin{ [[rational]] { \overset{ [[init_t]] }{ \mapsto } }_{ [[predicate_name]] } } [[IT_ts_ne2]] }}
      {{ ocaml { name = [[predicate_name]] ; pointer = List.hd [[IT_ts_ne1]] ; iargs = List.tl [[IT_ts_ne1]] ; oargs = [[IT_ts_ne2]] ; init = [[init_t]] ; perm = [[rational]] } }}


  resource :: '' ::=
    | predicate :: :: Predicate

metavar logical_val ::= {{ phantom }} {{ com logical values (to be specified) }}

grammar

  spine_elem :: Spine_Elem_ ::= {{ com spine element }}
    | mu_pval_aux :: :: pure_val    {{ com pure value       }}
    | logical_val :: :: logical_val {{ com logical variable }}
    | resource    :: :: resource    {{ com resource         }}

grammar

  arg :: ArgTy_ ::= {{ com argument types }}
    | pi tyvar_sym : base_type . arg     :: :: Computational
    | forall tyvar_sym : base_type . arg :: :: Logical
    | resource --o arg                   :: :: Resource
    | term_aux -) arg                    :: :: Constraint
    | ret                                :: :: Ret
    | [ spine_elem / tyvar_sym ] arg     :: M :: Substitution {{ ocaml ARG_SPINE_ELEM_SUB }}


  ret , _r {{ tex \_ }} :: RetTy_ ::= {{ com return types }}
    | sigma tyvar_sym : base_type . ret  :: :: Computational
    | exists tyvar_sym : base_type . ret :: :: Logical
    | resource *s ret                    :: :: Resource
    | term_aux /\ ret                    :: :: Constraint
    | I                                  :: :: I


grammar

  C {{ tex \mathcal{C} }} :: Comp_ ::= {{ phantom }} {{ com computational var env }}
    | cdot                  ::   :: empty
    | C , Symbol_sym : BT_t ::   :: cons
    | C , C'                ::   :: concat
    | fresh ( C )           :: M :: fresh {{ tex \mathrm{fresh}( [[C]] ) }}
                                               {{ ocaml FRESH_COMP_CONTEXT    }}
                                               {{ com identical context except with fresh variable names }}


grammar

  L {{ tex \mathcal{L} }} :: Log_ ::= {{ phantom }} {{ com logical var env }}
    | cdot           :: :: empty
    | L , Symbol_sym :: :: cons


grammar

  N {{ tex \Phi }} :: Con_ ::= {{ phantom }} {{ com constraints env }}
    | cdot     :: :: empty
    | N , term_aux :: :: cons


grammar

  R {{ tex \mathcal{R} }} :: Res_ ::= {{ phantom }} {{ com resources env }}
    | cdot         :: :: empty
    | R , resource :: :: cons


grammar

  formula :: 'formula_' ::=
    | judgement                                                                        :: :: judgement
    | smt ( N => term_aux )                                                            :: :: smt
    | Symbol_sym : base_type inEnv C                                                   :: :: xInC
    | Symbol_sym : struct ty_tag & </ Symbol_identifieri : T_cti // i /> inEnv Globals :: :: structInGlobals
    | </ Ci ; Li ; Ni |- ty_mem_valuei => mem yi : base_typei . term_auxi  // i />     :: :: indexed_infer_mem_value       {{ com dependent on memory object model }}
    | </ Ci ; Li ; Ni |- mu_pval_auxi => tyvar_symi : base_typei . term_auxi // i />       :: :: index_infer_mu_pval
    | </ mu_pattern_auxi : base_typei ~> Ci  // i />                                   :: :: indexed_pattern
    | </ Ci ; Li ; Ni |- mu_tpexpri <= yi : base_typei . termi // i />                 :: :: indexed_check_mu_tpexpr
    | L |- logical_val : base_type                                                     :: :: check_logical_value

% defns
%   mem_value_jtype  {{ com memory values are abstract, so the memory object model would need to provide such rules }} :: '' ::=
% 
% defn
%     C ; L ; N |- ty_mem_value => mem y , base_type , term :: :: Val_Obj_Mem :: Val_Obj_Mem_ by
%
% Duplication going on here (could factor out int, ptr, arr, and struct rules)
%
%    ---------------------------------------------------------------------------------- :: Int
%    C ; L ; N |- int ty_mem_int => mem y , integer , y = of_mem_int ty_mem_int
%
%
%    -------------------------------------------------------- :: Ptr_Null
%    C ; L ; N |- nullptr => mem y , loc , y = nullop
%
%
%    --------------------------------------------------------- :: Ptr_Func
%    C ; L ; N |- funcptr ident => mem y , loc , y = ident
%
%
%    ---------------------------------------------------------------------- :: Ptr_Conc
%    C ; L ; N |- concptr ty_nat => mem y , loc , y = ptr of_nat ty_nat
%
%
%    </ C ; L ; N |- ty_mem_valuei => mem yi , base_type , termi  // i />
%    -------------------------------------------------------------------------- :: Arr
%    C ; L ; N |- array ( </ ty_mem_valuei // i /> ) => mem y , array base_type ,  /\\ ( </  [ y [ int Z_ti ] / yi ] termi // i /> )
%
%
%    </ C ; L ; N |- ty_mem_valuei => mem yi , base_typei , termi  // i />
%    --------------------------------------------------------------------- :: Struct
%    C ; L ; N |- ( struct ty_tag ) { </ . Symbol_identifieri = ty_mem_valuei // i /> } => mem y , struct ty_tag ,  /\\ ( </ [ ty_tag y . Symbol_identifieri / yi ] termi // i /> )
%
%    % NOT IMPLEMENTED: union Symbol_sym Symbol_identifier

defns
  object_value_jtype :: '' ::=

  defn
    C ; L ; N |- mu_object_value => obj tyvar_sym : base_type . term_aux :: :: Pval_Obj_ :: Pval_Obj_ by


    -------------------------------------------------------------------------- :: Int
    C ; L ; N |- ty_mem_int => obj y : integer . y = of_mem_int ty_mem_int


    ------------------------------------------------------------------ :: Ptr
    C ; L ; N |- ty_mem_ptr => obj y : loc . y = of_mem_ptr ty_mem_ptr


%    -------------------------------------------------------- :: Ptr_Null
%    C ; L ; N |- nullptr => obj y , loc , y = nullop
%
%
%    --------------------------------------------------------- :: Ptr_Func
%    C ; L ; N |- funcptr ident => obj y , loc , y = ident
%
%
%    ---------------------------------------------------------------------- :: Ptr_Conc
%    C ; L ; N |- concptr ty_nat => obj y , loc , y = ptr of_nat ty_nat


    % only instance of mutually recursive call to mu_value_judgement, can be inlined away
    </ C ; L ; N |- mu_loaded_valuei => yi : base_type . term_auxi // i />
    -------------------------------------------------------------------------------------------------------------------------------------- :: Arr
    C ; L ; N |- array ( </ mu_loaded_valuei // i /> ) => obj y : array base_type .  /\\ ( </  [ y [ i ] / yi ] termi // i /> )


    Symbol_sym : struct ty_tag & </ Symbol_identifieri : T_cti // i /> inEnv Globals
    </ C ; L ; N |- ty_mem_valuei => mem yi : base_typei . term_auxi  // i />
    -------------------------------------------------------------------------------- :: Struct
    C ; L ; N |- ( struct ty_tag ) { </ dot Symbol_identifieri : T_cti = ty_mem_valuei //  i /> } => obj y : struct ty_tag .  /\\ ( </ [ ty_tag y dot Symbol_identifieri / yi ] termi // i /> )


    % NOT IMPLEMENTED: union
    % UNSUPPORTED: floats

defns
  pval_jtype :: '' ::=

  defn
    C ; L ; N |- mu_pval_aux => tyvar_sym : base_type . term_aux :: :: Pval :: Pval_ by


    x : base_type inEnv C
    --------------------------------------- :: Var
    C ; L ; N |- x => y : base_type . y = x


    % DEFER: impl_const (aka globals) needs resources


    C ; L ; N |- mu_object_value => obj y : base_type . term_aux
    ------------------------------------------------------------ :: Obj
    C ; L ; N |- mu_object_value => y : base_type . term


    C ; L ; N |- mu_object_value => obj y : base_type . term_aux
    -------------------------------------------------------------- :: Loaded
    C ; L ; N |- specified mu_object_value => y : base_type . term


    ---------------------------------------- :: Unit
    C ; L ; N |- Unit => y : unit . y = unit


    ---------------------------------------- :: True
    C ; L ; N |- True => y : bool . y = true


    ------------------------------------------ :: False
    C ; L ; N |- False => y : bool . y = false


    </ C ; L ; N |- mu_valuei =>  yi : base_type . termi // i />
    --------------------------------------------------------------------------------------------------------------- :: List
    C ; L ; N |- base_type [ </ mu_valuei // i /> ] => y : [ base_type ] .  /\\ ( </ [ y ^ i / yi ] termi // i /> )


    </ C ; L ; N |- mu_valuei =>  yi : base_typei . termi // i />
    ------------------------------------------------------------------------------------------------------------- :: Tuple
    C ; L ; N |- ( </ mu_valuei // i /> ) => y : </ base_typei // i /> .  /\\ ( </ [ y ^ i / yi ] termi // i /> )


    % NOT IMPLEMENTED: constrained


    smt ( N => false )
    -------------------------------------------------------------------------- :: Error
    C ; L ; N |- error ( ty_string , mu_pval_aux ) => y : base_type . term_aux


    ------------------------------------------------------------- :: Ctor_Nil
    C ; L ; N |- Nil base_type ( ) => y : [ base_type ] . y = nil


    C ; L ; N |- mu_pval1 => y1 : base_type . term1
    C ; L ; N |- mu_pval2 => y2 : [ base_type ] . term2
    --------------------------------------------------- :: Ctor_Cons
    C ; L ; N |- Cons ( mu_pval1, mu_pval2 ) => y : [ base_type ] . [ y ^ one / y1 ] term1 /\ [ tl y / y2 ] term2


    </ C ; L ; N |- mu_pvali => yi : base_typei . termi // i />
    ----------------------------------------------------------------------------------------------------------------- :: Ctor_Tuple
    C ; L ; N |- Tuple ( </ mu_pvali // i /> ) => y : </ base_typei // i /> . /\\ ( </ [ y ^ i / yi ] termi // i /> )


    % NOT IMPLEMENTED - empty arrays


    </ C ; L ; N |- mu_pvali => yi : base_type . termi // i />
    ------------------------------------------------------------------------------------------------------------- :: Ctor_Array
    C ; L ; N |- Array ( </ mu_pvali // i /> ) => y : array base_type . /\\ ( </ [ y [ i ] / yi ] termi // i /> )


    C ; L ; N |- mu_pval => y : base_type . term
    ---------------------------------------------------------- :: Ctor_Specified
    C ; L ; N |- Specified ( mu_pval ) => y : base_type . term


   </ C ; L ; N |- mu_pvali => yi : base_typei . termi // i />
   ------------------------------------------------------------ :: Struct
   C ; L ; N |- ( struct ty_tag ) { </ dot Symbol_identifieri = mu_pvali // i /> } => y : struct ty_tag .  /\\ ( </ [ ty_tag y dot Symbol_identifieri / yi ] termi // i /> )


   % NOT IMPLEMENTED: union

defns
  spine_jtype :: '' ::=

  defn
    C ; L ; N ; R |- </ spine_elemi // , // i /> :; arg >> ret :: :: Spine :: Spine_ by

    --------------------------------- :: Empty
    C ; L ; N ; cdot |- :; ret >> ret


    C ; L ; N |- mu_pval_aux => _ : base_type . _
    C ; L ; N ; R |- </ spine_elemi // i /> :; [ mu_pval_aux / x ] arg >> ret
    -------------------------------------------------------------------------------------- :: Computational
    C ; L ; N ; R |- mu_pval_aux , </ spine_elemi // i /> :; pi x : base_type . arg >> ret


    L |- logical_val : base_type
    C ; L ; N ; R |- </ spine_elemi // i /> :; [ logical_val / x ] arg >> ret
    ------------------------------------------------------------------------------------------- :: Logical
    C ; L ; N ; R |- logical_val , </ spine_elemi // i /> :;  forall x : base_type . arg >> ret


    smt ( N => resource = resource' )
    C ; L ; N ; R |- </ spine_elemi // i /> :; arg >> ret
    ------------------------------------------------------------------------------------------- :: Resource
    C ; L ; N ; R , resource |- resource' , </ spine_elemi // i /> :;  resource' --o arg >> ret


    smt ( N => term_aux )
    C ; L ; N ; R |- </ spine_elemi // i /> :; arg >> ret
    ------------------------------------------------------------------ :: Constraint
    C ; L ; N ; R |- </ spine_elemi // i /> :;  term_aux -) arg >> ret


defns
  pexpr_jtype :: '' ::=

  defn
    C ; L ; N |- mu_pexpr_aux => ident : base_type . term_aux :: :: PExpr :: PExpr_ by


    C ; L ; N |- mu_pval_aux => y : base_type . term
    ------------------------------------------------ :: Val
    C ; L ; N |- mu_pval_aux => y : base_type . term


   % NOT IMPLEMENTED - mu_ctor_expr
   % Ivmax       :: :: ivmax       {{ com max integer value              }} % : ctype -> integer
   % Ivmin       :: :: ivmin       {{ com min integer value              }} % : ctype -> integer
   % Ivsizeof    :: :: ivsizeof    {{ com sizeof value                   }} % : ctype -> integer
   % Ivalignof   :: :: ivalignof   {{ com alignof value                  }} % : ctype -> integer
   % IvCOMPL     :: :: ivCOMPL     {{ com bitwise complement             }} % : ctype -> integer -> integer
   % IvAND       :: :: ivAND       {{ com bitwise AND                    }} % : ctype -> integer -> integer -> integer
   % IvOR        :: :: ivOR        {{ com bitwise OR                     }} % : ctype -> integer -> integer -> integer
   % IvXOR       :: :: ivXOR       {{ com bitwise XOR                    }} % : ctype -> integer -> integer -> integer

   % Unsupported
   % Fvfromint   :: :: fvfromint   {{ com cast integer to floating value }} % : integer -> floating
   % Ivfromfloat :: :: ivfromfloat {{ com cast floating to integer value }} % : ctype -> floating -> integer


    C ; L ; N |- smt_pval_aux1 => _' : loc . _t'
    C ; L ; N |- smt_pval_aux2 => _'' : integer . _t''
    -------------------------------------------------------- :: Array_Shift
    C ; L ; N |- array_shift ( smt_pval_aux1 , ct , smt_pval_aux2 ) => y : loc . y = embed smt_pval_aux1 +ptr embed smt_pval_aux2 * to_int ct


    % TODO member_shift


    C ; L ; N |- smt_pval_aux => _' : bool . _t'
    -------------------------------------------------------------------------------- :: Not
    C ; L ; N |- not ( smt_pval_aux ) => y : bool . y = neg embed smt_pval_aux


    % TODO: op
    % arithmetic operators (integer -> integer -> integer)
    % +     :: :: Add   {{ tex \texttt{+}         }} {{ com addition       }}
    % -     :: :: Sub   {{ tex \texttt{-}         }} {{ com subtraction    }}
    % *     :: :: Mul   {{ tex \texttt{*}         }} {{ com multiplication }}
    % /     :: :: Div   {{ tex \texttt{/}         }} {{ com division       }}
    % rem_t :: :: Rem_t                              {{ com modulus        }}
    % rem_f :: :: Rem_f                              {{ com remainder      }}
    % ^     :: :: Exp   {{ tex \texttt{\char`^}   }} {{ com exponentiation }}
    % relational operators ( integer -> integer -> bool)
    % =     :: :: Eq    {{ tex \texttt{=}         }} {{ com equality, defined both for integer and C types }}
    % >     :: :: Gt    {{ tex \texttt{>}         }} {{ com greater than                                   }}
    % <     :: :: Lt    {{ tex \texttt{<}         }} {{ com less than                                      }}
    % >=    :: :: Ge    {{ tex \texttt{>=}        }} {{ com greater than or equal to                       }}
    % <=    :: :: Le    {{ tex \texttt{<=}        }} {{ com less than or equal to                          }}
    % logical connectives ( bool -> bool -> bool)
    % /\    :: :: And   {{ tex \texttt{/\char`\\} }} {{ com conjucntion }}
    % \/    :: :: Or    {{ tex \texttt{\char`\\/} }} {{ com disjunction }}

    % NOT IMPLEMENTED: op ~ memberof

    C ; L ; N |- mu_name => _ : base_type . _t
    C ; L ; N ; cdot |- mu_pval_aux1 , .. , mu_pval_auxn :; forall _ : base_type . I >> sigma y : base_type' . term' /\ I
    -------------------------------------------------------------------------------------------------------------------- :: Call
    C ; L ; N |- mu_name ( mu_pval_aux1 , .. , mu_pval_auxn ) => y : base_type' . term'

    % DEFER conv_int

    % TODO: assert_undef, bool_to_integer, wrapI

defns
  pattern_jtype :: '' ::=

  defn
    mu_pattern_aux : base_type ~> C :: :: Pattern_ :: Pattern_ by
  
    % TODO
  
  defn
    mu_sym_or_pattern : base_type ~> C :: :: Sym_Or_Pattern :: Sym_Or_Pattern by
  
    % TODO

defns
  tpval_jtype :: '' ::=

  defn
    C ; L ; N |- mu_tpval_aux <= ident : base_type . term_aux :: :: TPVal :: TPVal_ by
  
  
    smt ( N => false )
    ------------------------------------------------------------- :: Undef
    C ; L ; N |- undef ty_loc UB_name <= y : base_type . term_aux
  
  
    C ; L ; N |- mu_pval_aux => y : base_type . term'
    smt ( N , term'  => term )
    ----------------------------------------------------- :: Done
    C ; L ; N |- done mu_pval_aux <= y : base_type . term


defns
  tpexpr_jtype :: '' ::=

  defn
    C ; L ; N |- mu_tpexpr_aux <= ident : base_type . term_aux :: :: TPExpr :: TPExpr_ by
  
    % ASK boundary between inference/checking, should there be an SMT here?
    C ; L ; N |- smt_pval_aux => _ : bool . _t
    C ; L , y' ; N , embed smt_pval_aux = true  |- mu_tpexpr_aux1 <= y : base_type . term
    C ; L , y' ; N , embed smt_pval_aux = false |- mu_tpexpr_aux2 <= y : base_type . term
    -------------------------------------------------------------------------------------------- :: If
    C ; L ; N |- if smt_pval_aux then mu_tpexpr_aux1 else mu_tpexpr_aux2 <= y : base_type . term
  
  
    % ASK boundary between inference/checking, should there be an SMT here?
    % ASK should the constraints be propogated?
    C ; L ; N |- mu_pexpr_aux => _ : base_type . _t
    mu_sym_or_pattern : base_type ~> C'
    C , fresh ( C' ) ; L ; N |- [ fresh ( C' ) / C' ] mu_tpexpr <= y : base_type . term
    -------------------------------------------------------------------------------------- :: Let
    C ; L ; N |- let mu_sym_or_pattern = mu_pexpr_aux in mu_tpexpr <= y : base_type . term
  
  
    % ASK boundary between inference/checking, should there be an SMT here?
    % ASK should the constraints be propogated?
    C ; L ; N |- mu_pval_aux => _ : base_type . _t
    </ mu_patterni : base_type ~> Ci // i />
    </ C , fresh ( Ci ) ; L ; N |- [ fresh ( Ci ) / Ci ] mu_tpexpri <= y : base_type . term // i />
    --------------------------------------------------------------------------------------------------- :: Case
    C ; L ; N |- case mu_pval_aux of </ | mu_patterni => mu_tpexpri // i /> end <= y : base_type . term


defns
  action_jtype :: '' ::=
 
  defn
    C ; L ; N ; R |- mu_action_aux => ret :: :: Action :: Action_ by
    
    
    C ; L ; N |- smt_pval_aux => _ : integer . _t
    -------------------------------------------- :: Create
    C ; L ; N ; cdot |- create ( smt_pval_aux , ct ) Symbol_prefix => sigma yp : loc . exists y : to_base ( ct ) . representable ( ct ast , yp ) /\ alignedI ( embed smt_pval_aux , yp ) /\ [ yp ] ( one )|- * - ct -> [ y ] *s I


    % NOT IMPLEMENTED:
    % C ; L ; N ; cdot |-> create_readonly ( vp , ct , v ) Symbol_prefix => ??


    C ; L ; N |- smt_pval_aux1 => _ : loc . _t
    C ; L ; N |- smt_pval_aux' => _' : to_base ( ct ) . _t'
    % ASK can we store things of type (or types containing) arrays? If so, this rule is a problem
    % NOT IMPLEMENTED: locking boolean
    smt ( N => representable ( ct , embed smt_pval_aux' ) )
    smt ( N => embed smt_pval_aux0 = embed smt_pval_aux1 )
    -------------------------------------------------------- :: Store
    C ; L ; N ; cdot , [ embed smt_pval_aux0 ] ( one )|- _i - ct -> [ _t'' ] |- store ( _b , ct , smt_pval_aux1 , smt_pval_aux' , _mem_order ) => sigma _ : unit . [ embed smt_pval_aux0 ] ( one )|- tick - ct -> [ embed smt_pval_aux' ] *s I


    C ; L ; N |- smt_pval_aux1 => _ : loc . _t
    smt ( N => embed smt_pval_aux0 = embed smt_pval_aux1 )
    ---------------------------------------------------------------------------------------------------------------------------------- :: Kill_Static
    C ; L ; N ; cdot , [ embed smt_pval_aux0 ] ( one )|- _i - ct -> [ _t' ] |-  kill ( static ct , smt_pval_aux1 ) => sigma _ : unit . I


    % NOT IMPLEMENTED:
    % C ; L ; N ; ?? |- kill ( dynamic , v ) => ??


    % mu_action_aux {{ tex action\_aux }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions }}
    %   | alloc ( ty_asym1 , ty_asym2 ) Symbol_prefix                                                         :: :: Alloc
    %   | load ( ty_act , ty_asym , Cmm_memory_order )                                                        :: :: Load
    %   | rmw ( ty_act ,  ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )            :: :: RMW
    %   | fence ( Cmm_memory_order )                                                                          :: :: Fence
    %   | cmp_exch_strong ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: CompareExchangeStrong
    %   | cmp_exch_weak ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )   :: :: CompareExchangeWeak
    %   | linux_fence ( Linux_linux_memory_order )                                                            :: :: LinuxFence
    %   | linux_load ( ty_act , ty_asym , Linux_linux_memory_order )                                          :: :: LinuxLoad
    %   | linux_store ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                             :: :: LinuxStore
    %   | linux_rmw ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                               :: :: LinuxRMW

  defn
    C ; L ; N ; R |- mu_seq_expr_aux => ret :: :: Seq_Expr :: Seq_Expr_ by

    C ; L ; N |- mu_pval_aux => y : base_type . term
    ------------------------------------------------------------------ :: Pure
    C ; L ; N ; cdot |- mu_pval_aux => sigma y : base_type . term /\ I
  

    % TODO
    % ccall ( ty_act , ty_asym , </ ty_asymi // , // i /> ) :: :: ccall  {{ com C function call             }}
    % pcall ( mu_name , </ ty_asymi // , // i /> )          :: :: proc   {{ com procedure call              }}

  defn
    C ; L ; N ; R |- mu_is_expr_aux => ret :: :: IS_Expr :: IS_Expr_ by
  
  
    C ; L ; N ; R |- mu_action => ret
    --------------------------------- :: Action
    C ; L ; N ; R |- Pos mu_action => ret
  
  
    C ; L ; N ; R |- mu_action => ret
    ----------------------------------------- :: Neg_Action
    C ; L ; N ; R |- Neg mu_action => ret

    % TODO
    % memop ( mu_memop )                                    :: :: memop  {{ com pointer op involving memory }}
    % skip                                                  :: :: skip   {{ com skip                        }}

