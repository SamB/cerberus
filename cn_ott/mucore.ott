% Categories
% X - hide from Tex
% O - hide from OCaml

embed {{ tex-preamble
\geometry{landscape}
\renewcommand{\[[TEX_NAME_PREFIX]]kw}[1]{ \texttt{#1} }
\renewcommand{\[[TEX_NAME_PREFIX]]drule}[4][]{ {\displaystyle\frac{\begin{array}{l}#2\end{array} }{#3}\quad\[[TEX_NAME_PREFIX]]drulename{#4} }\\[\baselineskip] }
}}

metavar ident , x , y , yp {{ tex { y_p } }} , yf {{ tex { y_f } }} , _ , abbrev , r ::= {{ phantom }}
  {{ com subscripts: p for pointers, f for functions }}

indexvar n , i , j ::= {{ phantom }} {{ com index variables }}

grammar

  Sctypes_t , ct {{ tex \tau }} :: '' ::= {{ ocaml Sctypes.t }} {{ phantom }} {{ com C type }}
    | ct ast :: :: Pointer {{ com pointer to type $[[ct]]$ }} {{ tex [[ct]] { [[ast]] } }}


grammar

  ty_tag {{ tex tag }} :: 'Ty_tag' ::= {{ ocaml tag }} {{ phantom }} {{ com OCaml type for struct/union tag }}
    | ident :: :: ident

  base_type {{ tex \beta }} , _bt {{ tex \_ }} :: '' ::= {{ com base types }}
    | unit                                       ::   :: Unit    {{ com unit              }}
    | bool                                       ::   :: Bool    {{ com boolean           }}
    | integer                                    ::   :: Integer {{ com integer           }}
    | real                                       ::   :: Read    {{ com rational numbers? }}
    | loc                                        ::   :: Loc     {{ com location          }}
    | array base_type                            ::   :: Array   {{ com array             }}
    | list base_type                             ::   :: ListTy  {{ com list              }}
    | </ base_typei // * // i />                 ::   :: TupleTy {{ com tuple             }}
    | struct ty_tag                              ::   :: Struct  {{ com struct            }}
    | set base_type                              ::   :: Set     {{ com set               }}
    | opt ( base_type )                          ::   :: Option  {{ com option            }}
    | base_type -> base_type'                    ::   :: ParamTy {{ com parameter types   }}
    | to_base ( ct )                             :: M :: Of_Ctype {{ com of a C type      }}
                                                                 {{ tex \beta_{ [[ct]] } }}
                                                                 {{ ocaml (BT.of_sct ( [[ct]] ) )   }}

grammar

  % Binary operators
  binop {{ tex \mathbin{ binop } }}:: 'Op' ::= {{ ocaml Core.binop }} {{ phantom }} {{ com binary operators }}
    % arithmetic operators (integer -> integer -> integer)
    | +     :: :: Add   {{ tex \mathbin{ \texttt{+} } }} {{ com addition       }}
    | -     :: :: Sub   {{ tex \mathbin{ \texttt{-} } }} {{ com subtraction    }}
    | *     :: :: Mul   {{ tex \mathbin{ \texttt{*} } }} {{ com multiplication }}
    | /     :: :: Div   {{ tex \mathbin{ \texttt{/} } }} {{ com division       }}
    | rem_t :: :: Rem_t {{ tex \mathbin{ [[rem_t]] }  }} {{ com modulus        }}
    | rem_f :: :: Rem_f {{ tex \mathbin{ [[rem_f]] }  }} {{ com remainder      }}
    | ^     :: :: Exp                                    {{ com exponentiation }}
    % relational operators ( integer -> integer -> bool)
    | =     :: :: Eq    {{ tex \mathbin{ \texttt{=}  } }} {{ com equality, defined both for integer and C types }}
    | >     :: :: Gt    {{ tex \mathbin{ \texttt{>}  } }} {{ com greater than                                   }}
    | <     :: :: Lt    {{ tex \mathbin{ \texttt{<}  } }} {{ com less than                                      }}
    | >=    :: :: Ge    {{ tex \mathbin{ \texttt{>=} } }} {{ com greater than or equal to                       }}
    | <=    :: :: Le    {{ tex \mathbin{ \texttt{<=} } }} {{ com less than or equal to                          }}
    % logical connectives ( bool -> bool -> bool)
    | /\    :: :: And   {{ tex \mathbin{ \texttt{/\char`\\} } }} {{ com conjucntion }}
    | \/    :: :: Or    {{ tex \mathbin{ \texttt{\char`\\/} } }} {{ com disjunction }}


  arith_binop {{ tex \mathbin{ binop_{arith} } }} :: 'Arith_Op' ::= {{ phantom }} {{ com arithmentic binary operators }}
    | +     :: :: Add
    | -     :: :: Sub
    | *     :: :: Mul
    | /     :: :: Div
    | rem_t :: :: Rem_t
    | rem_f :: :: Rem_f
    | ^     :: :: Exp


  rel_binop {{ tex \mathbin{ binop_{rel} } }} :: 'Rel_Op' ::= {{ phantom }} {{ com relational binary operators }}
    | =     :: :: Eq
    | >     :: :: Gt
    | <     :: :: Lt
    | >=    :: :: Ge
    | <=    :: :: Le


  bool_binop {{ tex \mathbin{ binop_{bool} } }} :: 'Bool_Op' ::= {{ phantom }} {{ com boolean binary operators }}
    | /\    :: :: And
    | \/    :: :: Or


  subrules
    arith_binop <:: binop
    rel_binop   <:: binop
    bool_binop  <:: binop


metavar impl_const ::= {{ ocaml Implementation.implementation_constant }} {{ phantom }}
  {{ com implementation-defined constant }}

grammar

  tyvar_sym {{ tex ident }}:: 'Tyvar_sym_' ::= {{ ocaml 'sym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ident :: :: ident

metavar ty_mem_int {{ tex mem\_int }} ::= {{ ocaml Impl_mem.integer_value }} {{ phantom }}
  {{ com memory integer value }}

metavar Symbol_identifier {{ tex member }} ::= {{ ocaml Symbol.identifier }} {{ phantom }}
  {{ com C struct/union member name }}

metavar annots {{ tex }} ::= {{ ocaml annot list }} {{ phantom }}
  {{ com Ott-hack, ignore (annotations) }}

metavar ty_nat {{ tex nat }} ::= {{ ocaml Nat_big_num.num }} {{ phantom }}
  {{ com OCaml arbitrary-width natural number }}

metavar ty_mem_ptr {{ tex mem\_ptr }} ::= {{ ocaml Impl_mem.pointer_value }} {{ phantom }}
    {{ com abstract pointer value }}

%   ty_mem_ptr {{ tex mem\_ptr }} :: 'PV' ::= {{ ocaml Impl_mem.pointer_value }} {{ phantom }} {{ com pointer values }}
%     | nullptr            :: :: null       {{ com null pointer }}
%     | funcptr Symbol_sym :: :: function   {{ com function pointer }}
%     | concptr ty_nat     :: :: concrete   {{ com concrete pointer }}

metavar ty_mem_value {{ tex mem\_val }} ::= {{ phantom }} {{ ocaml Impl_mem.mem_value }}
    {{ com abstract memory value }}

% ty_mem_value {{ tex mem\_val }} :: 'MV' ::= {{ phantom }} {{ ocaml Impl_mem.mem_value }} {{ com memory value }}
%     | int ty_mem_int                                                                 :: :: integer
%     | ty_mem_ptr                                                                     :: :: pointer
%     | array ( </ ty_mem_valuei // i /> )                                             :: :: array
%     | ( struct Symbol_sym ) { </ . Symbol_identifieri = ty_mem_valuei // , // i /> } :: :: struct
%     | union Symbol_sym Symbol_identifier                                             :: :: union


grammar

  T_ct {{ tex \tau }} :: 'T_ct_of_' ::= {{ ocaml T.ct }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ct :: :: ct

grammar

  Symbol_sym {{ tex ident }}:: '' ::= {{ ocaml Symbol.sym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ident  :: :: ident
    | ty_tag :: :: ty_tag {{ com hack for struct typing rules }}


grammar

  mu_object_value {{ tex object\_value }} :: 'M_OV' ::=  {{ auxparam 'TY }} {{ com C object values (inhabitants of object types), which can be read/stored }}
    | ty_mem_int                                                                                :: :: integer {{ com integer value  }}
    | ty_mem_ptr                                                                                :: :: pointer {{ com pointer value  }}
    | array ( </ mu_loaded_valuei // , // i /> )                                                :: :: array   {{ com C array value  }}
    | ( struct Symbol_sym ) { </ dot Symbol_identifieri : T_cti = ty_mem_valuei // , // i /> }  :: :: struct  {{ com C struct value }}
    | ( union Symbol_sym ) { dot Symbol_identifier = ty_mem_value }                             :: :: union   {{ com C union value  }}


  mu_loaded_value {{ tex loaded\_value }} :: 'M_LV' ::= {{ auxparam 'TY }} {{ com potentially unspecified C object values }}
    | specified mu_object_value :: :: specified {{ com specified loaded value }}


grammar

  T_bt {{ tex \beta }} :: 'T_bt_' ::= {{ ocaml T.bt }} {{ phantom }} {{ com Ott-hack, ignore }}
    | base_type :: :: BaseType


grammar

  mu_value {{ tex value }} :: 'M_V' ::= {{ auxparam 'TY }} {{ com Core values }}
    | mu_object_value                    :: :: object {{ com C object value        }}
    | mu_loaded_value                    :: :: loaded {{ com loaded C object value }}
    | Unit                               :: :: unit   {{ com unit                  }}
    | True                               :: :: true   {{ com boolean true          }}
    | False                              :: :: false  {{ com boolean false         }}
    | T_bt [ </ mu_valuei // , // i /> ] :: :: list   {{ com list                  }}
    | ( </ mu_valuei // , // i /> )      :: :: tuple  {{ com tuple                 }}


grammar

  mu_ctor_val {{ tex ctor\_val }} :: 'M_C' ::= {{ com data constructors }}
    | Nil T_bt    :: :: nil         {{ com empty list                     }} % : [bTy]
    | Cons        :: :: cons        {{ com list cons                      }} % : bTy -> [bTy] -> [bTy]
    | Tuple       :: :: tuple       {{ com tuple                          }} % : bTy1 -> ... -> bTyN -> (bTy1, ..., bTyN)
    | Array       :: :: array       {{ com C array                        }} % : bTy -> ... -> bTy -> array bTy
    | Specified   :: :: specified   {{ com non-unspecified loaded value   }} % : objTy -> loaded objTy


  mu_ctor_expr {{ tex ctor\_expr }} :: 'M_C' ::= {{ com data constructors }}
    | Ivmax       :: :: ivmax       {{ com max integer value              }} % : ctype -> integer
    | Ivmin       :: :: ivmin       {{ com min integer value              }} % : ctype -> integer
    | Ivsizeof    :: :: ivsizeof    {{ com sizeof value                   }} % : ctype -> integer
    | Ivalignof   :: :: ivalignof   {{ com alignof value                  }} % : ctype -> integer
    | IvCOMPL     :: :: ivCOMPL     {{ com bitwise complement             }} % : ctype -> integer -> integer
    | IvAND       :: :: ivAND       {{ com bitwise AND                    }} % : ctype -> integer -> integer -> integer
    | IvOR        :: :: ivOR        {{ com bitwise OR                     }} % : ctype -> integer -> integer -> integer
    | IvXOR       :: :: ivXOR       {{ com bitwise XOR                    }} % : ctype -> integer -> integer -> integer
    | Fvfromint   :: :: fvfromint   {{ com cast integer to floating value }} % : integer -> floating
    | Ivfromfloat :: :: ivfromfloat {{ com cast floating to integer value }} % : ctype -> floating -> integer


metavar ty_loc {{ tex }} ::= {{ ocaml Location_ocaml.t }} {{ phantom }}
  {{ com Ott-hack, ignore (locations) }}

metavar Mem_mem_iv_constraint {{ tex mem\_iv\_c }} ::= {{ ocaml Mem.mem_iv_constraint }} {{ phantom }}
  {{ com OCaml type for memory constraints on integer values }}

metavar UB_name ::= {{ ocaml Undefined.undefined_behaviour }} {{ phantom }}
 {{ com undefined behaviour }}

metavar ty_string {{ tex string }} ::= {{ ocaml string }} {{ phantom }}
  {{ com OCaml string }}

metavar tyvar_TY {{ tex }} ::= {{ ocaml 'TY }} {{ phantom }}
  {{ com Ott-hack, ignore (OCaml type variable TY) }}


grammar

  ty_act {{ tex \tau }} :: 'Ty_act_of' ::= {{ ocaml 'TY act }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ct :: :: ct


grammar

  mu_name {{ tex name }} :: '' ::= {{ ocaml Symbol.sym Core.generic_name }} {{ phantom }}
    | Symbol_sym :: :: Sym  {{ com Core identifier                 }}
    | impl_const :: :: Impl {{ com implementation-defined constant }}


grammar

  mu_pval {{ tex pval }} :: 'M_PV' ::= {{ auxparam 'TY }} {{ com pure values }}
    | Symbol_sym                                                                      :: :: sym          {{ com Core identifier                           }}
    | impl_const                                                                      :: :: impl         {{ com implementation-defined constant           }}
    | mu_value                                                                        :: :: mu_val       {{ com Core values                               }}
    | constrained ( </ Mem_mem_iv_constrainti , mu_pval_auxi // , // i /> )           :: :: constrained  {{ com constrained value                         }}
    | error ( ty_string , mu_pval_aux )                                               :: :: error        {{ com impl-defined static error                 }}
    | mu_ctor_val ( </ mu_pval_auxi // , // i /> )                                    :: :: ctor         {{ com data constructor application              }}
    | ( struct Symbol_sym ) { </ dot Symbol_identifieri = mu_pval_auxi // , // i /> } :: :: struct       {{ com C struct expression                       }}
    | ( union Symbol_sym ) { dot Symbol_identifier = mu_pval_aux }                    :: :: union        {{ com C union expression                        }}


  mu_pval_aux {{ tex pval }} :: 'M_P' ::= {{ auxparam 'TY }} {{ com pure values with auxiliary info }}
    | ty_loc annots tyvar_TY mu_pval :: X :: val
    |                        mu_pval :: O :: val_no_aux {{ com Ott-hack for simpler typing rules }}


  subrules
    mu_name <:: mu_pval


grammar

  mu_pexpr {{ tex pexpr }} :: 'M_PE' ::= {{ auxparam 'TY }} {{ com pure expressions }}
    | mu_pval_aux                                                   :: :: pval         {{ com pure values                               }}
    | mu_ctor_expr ( </ mu_pval_auxi // , // i /> )                 :: :: ctor         {{ com data constructor application              }}
    | array_shift ( mu_pval_aux1 , T_ct , mu_pval_aux2 )            :: :: array_shift  {{ com pointer array shift                       }}
    | member_shift ( mu_pval_aux , Symbol_sym , Symbol_identifier ) :: :: member_shift {{ com pointer struct/union member shift         }}
    | not ( mu_pval_aux )                                           :: :: not          {{ com boolean not                               }}
    | mu_pval_aux1 binop mu_pval_aux2                               :: :: op           {{ order [[binop]] [[mu_pval_aux1]] [[mu_pval_aux2]] }} {{ com binary operations }}
    | memberof  ( Symbol_sym , Symbol_identifier , mu_pval_aux )    :: :: memberof     {{ com C struct/union member access              }}
    | mu_name ( </ mu_pval_auxi // , // i /> )                      :: :: call         {{ com pure function call                        }}

    | assert_undef ( mu_pval_aux , ty_loc UB_name )                 :: :: assert_undef
    | bool_to_integer ( mu_pval_aux )                               :: :: bool_to_integer
    | conv_int ( ty_act , mu_pval_aux )                             :: :: conv_int
    | wrapI ( ty_act , mu_pval_aux )                                :: :: wrapI


  mu_pexpr_aux {{ tex pexpr }} :: 'M_P' ::= {{ auxparam 'TY }} {{ com pure expressions with location and annotations }}
    | ty_loc annots tyvar_TY mu_pexpr :: X :: expr
    |                        mu_pexpr :: O :: expr_no_aux {{ com Ott-hack for simpler typing rules }}


grammar

  mu_tpval {{ tex tpval }} :: 'M_TPV' ::= {{ auxparam 'TY }} {{ com top-level pure values }}
    | undef ty_loc UB_name :: :: undef {{ com undefined behaviour }}
    | done mu_pval_aux     :: :: done  {{ com pure done           }}


  mu_tpval_aux {{ tex tpval }} :: 'M_TP' ::= {{ auxparam 'TY }} {{ com top-level pure values with location and annotations }}
    | ty_loc annots tyvar_TY mu_tpval :: X :: val
    |                        mu_tpval :: O :: val_no_aux   {{ com Ott-hack for simpler typing rules }}


grammar

  ty_sym_opt_T_bt {{ tex ident\_opt\_\beta }} :: '' ::= {{ ocaml ( Symbol.sym option * T.bt ) }} {{ phantom }}
                                                        {{ com type annotated optional identifier }}
    | _ : T_bt          :: :: No_sym % (+ binders = {} +)
    | Symbol_sym : T_bt :: :: Just   % (+ binders = Symbol_sym +)


grammar

  mu_pattern {{ tex pattern }} :: 'M_Case' ::=
    | ty_sym_opt_T_bt                                 :: :: Base % (+ binders = binders( maybesym_base_type ) +)
    | mu_ctor_val ( </ mu_pattern_auxi // , // i /> ) :: :: Ctor % (+ binders = binders( </ mu_pattern_auxi // , // i /> ) +)


  mu_pattern_aux {{ tex pattern }} :: 'M_' ::=
    | ty_loc annots mu_pattern :: X :: Pattern                                                % (+ binders = binders(mu_pattern) +)
    |               mu_pattern :: O :: Pat_no_aux {{ com Ott-hack for simpler typing rules }} % (+ binders = binders(mu_pattern) +)


grammar

  mu_sym_or_pattern {{ tex ident\_or\_pattern }} :: 'M_' ::= {{ auxparam 'TY }}
    | Symbol_sym     :: :: Symbol % (+ binders = Symbol_sym +)
    | mu_pattern_aux :: :: Pat    % (+ binders = binders(mu_pattern_aux) +)


grammar

  mu_tpexpr {{ tex tpexpr }} :: 'M_TPE' ::= {{ auxparam 'TY }} {{ com top-level pure expressions }}
    | mu_tpval_aux                                                           ::   :: tpval {{ com top-level pure values }}
    | case mu_pval_aux of </ | mu_pattern_auxi => mu_tpexpr_auxi // i /> end ::   :: case  {{ com pattern matching      }} % TODO: binding
    | let mu_sym_or_pattern = mu_pexpr_aux in mu_tpexpr_aux                  ::   :: let   {{ com pure let              }} % TODO: binding
    | if mu_pval_aux then mu_tpexpr_aux1 else mu_tpexpr_aux2                 ::   :: if    {{ com pure if               }}
    | [ C / C' ] mu_tpexpr                                                   :: M :: contextSub {{ ocaml MU_TPEXPR_CONTEXT_SUB [[C]] [[C']] [[mu_tpexpr]] }}
                                                                                     {{ com simul-sub all vars in $[[C]]$ for all vars in $[[C']]$ in $[[mu_tpexpr]]$ }}


  mu_tpexpr_aux {{ tex tpexpr }} :: 'M_TP' ::= {{ auxparam 'TY }} {{ com pure top-level pure expressions with auxiliary info }}
    | ty_loc annots tyvar_TY mu_tpexpr :: X :: expr
    |                        mu_tpexpr :: O :: expr_no_aux   {{ com Ott-hack for simpler typing rules }}


grammar

  m_kill_kind :: 'M_' ::=
    | dynamic     :: :: Dynamic
    | static T_ct :: :: Static


grammar

  ty_bool {{ tex bool }} , _b {{ tex \_ }} :: '' ::=   {{ ocaml bool  }} {{ phantom }} {{ com OCaml booleans }}
    | true  :: :: True  {{ ocaml true  }}
    | false :: :: False {{ ocaml false }}


  ty_int {{ tex int }} , _int {{ tex \_ }} :: 'Int_' ::=   {{ ocaml int  }} {{ phantom }} {{ com OCaml fixed-width integer }}
    | i     ::   :: IndexVar {{ com literal integer }}
    | i_one :: X :: One      {{ tex 1               }}


metavar Symbol_prefix {{ tex }} ::= {{ ocaml Symbol.prefix }} {{ phantom }}
  {{ com Ott-hack, ignore (OCaml Symbol.prefix) }}

metavar Cmm_memory_order {{ tex mem\_order }} , _mem_order {{ tex \_ }} ::= {{ ocaml Cmm_csem.memory_order }} {{ phantom }}
  {{ com OCaml type for memory order }}

metavar Linux_linux_memory_order {{ tex linux\_mem\_order }} ::= {{ ocaml Linux.linux_memory_order }} {{ phantom }}
  {{ com OCaml type for Linux memory order }}

grammar

  mu_action {{ tex mem\_action }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions }}
    | create ( mu_pval_aux , ty_act ) Symbol_prefix                                                                   :: :: Create
    | create_readonly ( mu_pval_aux1 , ty_act , mu_pval_aux2 ) Symbol_prefix                                          :: :: CreateReadOnly
    | alloc ( mu_pval_aux1 , mu_pval_aux2 ) Symbol_prefix                                                             :: :: Alloc
    | kill ( m_kill_kind , mu_pval_aux )                                                                              :: :: Kill
    | store ( ty_bool , ty_act , mu_pval_aux1 , mu_pval_aux2 , Cmm_memory_order )                                     :: :: Store {{ com true means store is locking }}
    | load ( ty_act , mu_pval_aux , Cmm_memory_order )                                                                :: :: Load
    | rmw ( ty_act ,  mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 , Cmm_memory_order1 , Cmm_memory_order2 )            :: :: RMW
    | fence ( Cmm_memory_order )                                                                                      :: :: Fence
    | cmp_exch_strong ( ty_act , mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: CompareExchangeStrong
    | cmp_exch_weak ( ty_act , mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 , Cmm_memory_order1 , Cmm_memory_order2 )   :: :: CompareExchangeWeak
    | linux_fence ( Linux_linux_memory_order )                                                                        :: :: LinuxFence
    | linux_load ( ty_act , mu_pval_aux , Linux_linux_memory_order )                                                  :: :: LinuxLoad
    | linux_store ( ty_act , mu_pval_aux1 , mu_pval_aux2 , Linux_linux_memory_order )                                 :: :: LinuxStore
    | linux_rmw ( ty_act , mu_pval_aux1 , mu_pval_aux2 , Linux_linux_memory_order )                                   :: :: LinuxRMW


  mu_action_aux {{ tex mem\_action }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions with auxiliary info }}
    | ty_loc mu_action :: X :: Action
    |        mu_action :: O :: no_aux {{ com Ott-hack for simpler typing rules }}


grammar

  polarity :: '' ::= {{ ocaml Core.polarity }} {{ phantom }} {{ com polarities for memory actions }}
    | Pos :: :: Pos {{ com sequenced by \ottkw{let\ weak} and \ottkw{let\ strong} }}
    | Neg :: :: Neg {{ com only sequenced by \ottkw{let\ strong} }}


  mu_paction {{ tex pol\_mem\_action }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions with polarity }}
    | polarity mu_action_aux :: :: Paction


grammar

  mu_memop {{ tex mem\_op }} :: 'M_' ::=  {{ auxparam 'TY }} {{ com operations involving the memory state}}
    | mu_pval_aux1 == mu_pval_aux2                            :: :: PtrEq            {{ com pointer equality comparison }}
    | mu_pval_aux1 <> mu_pval_aux2                            :: :: PtrNe            {{ com pointer inequality comparison }}
    | mu_pval_aux1 < mu_pval_aux2                             :: :: PtrLt            {{ com pointer less-than comparison }}
    | mu_pval_aux1 > mu_pval_aux2                             :: :: PtrGt            {{ com pointer greater-than comparison }}
    | mu_pval_aux1 =< mu_pval_aux2                            :: :: PtrLe            {{ com pointer less-than comparison }}
    | mu_pval_aux1 >= mu_pval_aux2                            :: :: PtrGe            {{ com pointer greater-than comparison }}
    | mu_pval_aux1 - ty_act - mu_pval_aux2                    :: :: Ptrdiff          {{ order [[ty_act]] [[mu_pval_aux1]] [[mu_pval_aux2]] }} {{ com pointer subtraction }}
                                                                               {{ tex [[mu_pval_aux1]] -_{ [[ty_act]] } [[mu_pval_aux2]] }}
    | intFromPtr ( ty_act1 , ty_act2 , mu_pval_aux )          :: :: IntFromPtr       {{ com cast of pointer value to integer value }}
    | ptrFromInt ( ty_act1 , ty_act2 , mu_pval_aux )          :: :: PtrFromInt       {{ com cast of integer value to pointer value }}
    | ptrValidForDeref ( ty_act , mu_pval_aux )               :: :: PtrValidForDeref {{ com dereferencing validity predicate }}
    | ptrWellAligned ( ty_act , mu_pval_aux )                 :: :: PtrWellAligned
    | ptrArrayShift ( mu_pval_aux1 ,  ty_act , mu_pval_aux2 ) :: :: PtrArrayShift
    | memcpy ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )   :: :: Memcpy
    | memcmp ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )   :: :: Memcmp
    | realloc ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )  :: :: Realloc
    | va_start ( mu_pval_aux1 , mu_pval_aux2 )                :: :: Va_start
    | va_copy ( mu_pval_aux )                                 :: :: Va_copy
    | va_arg ( mu_pval_aux , ty_act )                         :: :: Va_arg
    | va_end ( mu_pval_aux )                                  :: :: Va_end


metavar logical_val ::= {{ phantom }} {{ com logical values (to be specified) }}

grammar

  res_term :: 'ResT_' ::= {{ com resource terms }}
    | emp                              :: :: Empty    {{ com empty heap }}
    | pt                               :: :: PointsTo {{ com single-cell heap }}
    | Symbol_sym                       :: :: Var      {{ com variable }}
    | <( res_term1 , res_term2 )>      :: :: SepPair  {{ com seperating-conjunction pair }}
    | pack ( mu_pval_aux , res_term2 ) :: :: Pack     {{ com packing for existentials }}


grammar

  spine_elem :: Spine_Elem_ ::= {{ com spine element }}
    | mu_pval_aux :: :: pure_val    {{ com pure value       }}
    | logical_val :: :: logical_val {{ com logical variable }}
    | res_term    :: :: res_val     {{ com resource valuel  }}


grammar

   mu_tval {{ tex tval }} :: 'M_TV' ::= {{ auxparam 'TY }} {{ com (effectful) top-level values }}
    | done </ spine_elemi //  , // i /> :: :: done  {{ com end of top-level expression }}
    | undef ty_loc UB_name              :: :: undef {{ com undefined behaviour         }}


   mu_tval_aux {{ tex tval }} :: 'M_T' ::= {{ auxparam 'TY }} {{ com (effectful) top-level values with auxiliary info }}
     | ty_loc annots mu_tval :: X :: val
     |               mu_tval :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


grammar

  res_pattern :: 'ResP_' ::= {{ com resource terms }}
    | emp                               :: :: Empty    {{ com empty heap }}
    | pt                                :: :: PointsTo {{ com single-cell heap }}
    | Symbol_sym                        :: :: Var      {{ com variable }}
    | <( res_pattern1 , res_pattern2 )> :: :: SepPair  {{ com seperating-conjunction pair }}
    | pack ( Symbol_sym , res_pattern ) :: :: Pack     {{ com packing for existentials }}


grammar

  ret_pattern :: RetP_ ::= {{ com return pattern }}
    | comp mu_sym_or_pattern :: :: computational {{ com computational variable }}
    | log  Symbol_sym        :: :: logical       {{ com logical variable       }}
    | res  res_pattern       :: :: resource      {{ com resource variable      }}


grammar

  bool_op :: '' ::= {{ auxparam 'bt }}
    | neg term_aux                         ::     :: Not
    | term_aux1 = term_aux2                ::     :: Eq
    | /\\ ( </ term_auxi // , // i />    ) ::     :: And
    | \// ( </ term_auxi // , // i />    ) ::     :: Or
    | term_aux1 /\ term_aux2               :: X M :: And_Binary {{ ocaml And ( [ [[term_aux1]] , [[term_aux2]] ] ) }}
    | term_aux1 \/ term_aux2               :: X M :: Or_Binary {{ ocaml Or ( [ [[term_aux1]] , [[term_aux2]] ] ) }}
    | term_aux1 ' bool_binop ' term_aux2   ::   M :: Bool_binop
      {{ tex [[term_aux1]] [[bool_binop]] [[term_aux2]] }}
      {{ ocaml BOOL_BINOP_TO_BOOL_OP [[term_aux1]] [[bool_binop]] [[term_aux2]] }}
    | if term_aux1 then term_aux2 else term_aux3  :: :: ITE


  arith_op :: '' ::= {{ auxparam 'bt }}
    | term_aux1 +     term_aux2            ::   :: Add
    | term_aux1 -     term_aux2            ::   :: Sub
    | term_aux1 *     term_aux2            ::   :: Mul
    | term_aux1 /     term_aux2            ::   :: Div
    | term_aux1 rem_t term_aux2            ::   :: Rem_t
    | term_aux1 rem_f term_aux2            ::   :: Rem_f
    | term_aux1 ^     term_aux2            ::   :: Exp
    | term_aux1 ' arith_binop ' term_aux2  :: M :: Arith_binop
      {{ tex [[term_aux1]] [[arith_binop]] [[term_aux2]] }}
      {{ ocaml ARITH_BINOP_TO_ARITH_OP [[term_aux1]] [[arith_binop]] [[term_aux2]] }}


  cmp_op :: '' ::= {{ auxparam 'bt }}
    | term_aux1 <  term_aux2            ::   :: LT {{ com less than          }}
    | term_aux1 =< term_aux2            ::   :: LE {{ com less than or equal }}
    | term_aux1 ' rel_binop ' term_aux2 :: M :: Rel_binop
      {{ tex [[term_aux1]] [[rel_binop]] [[term_aux2]] }}
      {{ ocaml REL_BINOP_TO_CMP_OP [[term_aux1]] [[rel_binop]] [[term_aux2]] }}


  list_op :: '' ::= {{ auxparam 'bt }}
    | nil                   :: :: Nil
    | tl term_aux           :: :: Tail
    | ty_int th_l term_aux :: :: NthList {{ order [[ty_int]] [[term_aux]]   }}
                                       {{ tex [[term_aux]]^{([[ty_int]])} }}

  tuple_op :: '' ::= {{ auxparam 'bt }}
    | ( </ term_auxi // , // i /> ) :: :: Tuple
    | ty_int th_t term_aux          :: :: NthTuple {{ tex [[term_aux]]^{([[ty_int]])} }}


  pointer_op :: '' ::= {{ auxparam 'bt }}
    | ty_mem_ptr                :: :: Null
    | term_aux1 +ptr term_aux2  :: :: AddPointer


  BT_t {{ tex \beta }} :: '' ::= {{ ocaml BT.t }} {{ phantom }} {{ com Ott-hack, ignore }}
    | base_type :: :: Base_type


  option_op :: '' ::= {{ auxparam 'bt }}
    | none BT_t     :: :: Nothing
    | some term_aux :: :: Something


  array_op :: '' ::= {{ auxparam 'bt }}
    | term_aux1 [ term_aux2 ]     :: :: ArrayGet


  param_op :: '' ::= {{ auxparam 'bt }}
    | Symbol_sym : base_type . term_aux       :: :: Param
    | term_aux ( term_aux1 , .. , term_auxn ) :: :: App


  struct_op :: '' ::= {{ auxparam 'bt }}
    | ty_tag term_aux dot Symbol_identifier :: :: StructMember {{ tex [[term_aux]] [[dot]] [[Symbol_identifier]] }}


  ct_pred :: '' ::= {{ auxparam 'bt }}
    | representable ( ct , term_aux )    :: :: Representable
    | alignedI ( term_aux1 , term_aux2 ) :: :: AlignedI


  term , _t {{ tex \_ }} :: '' ::= {{ auxparam 'bt }}
    | lit        :: :: Lit
    | arith_op   :: :: Arith_op
    | bool_op    :: :: Bool_op
    | cmp_op     :: :: Cmp_op
    | tuple_op   :: :: Tuple_op
    | struct_op  :: :: Struct_op
    | pointer_op :: :: Pointer_op
    | list_op    :: :: List_op
    | array_op   :: :: Array_op
    | ct_pred    :: :: CT_pred
    | option_op  :: :: Option_op
    | param_op   :: :: Param_op

    | ( term )                     :: S :: Paren   {{ ocaml [[term]] }} {{ com parentheses }}
    | [ term1 / Symbol_sym ] term2 :: M :: Subs    {{ ocaml INDEX_TERM_SUB [[term1]] [[Symbol_sym]] [[term2]] }} {{ com substitute $[[term1]]$ for $[[Symbol_sym]]$ in $[[term2]]$ }}
    | embed mu_pval_aux            :: M :: Of_pval {{ tex [[mu_pval_aux]] }} {{ ocaml TERM_OF_PVAL_AUX [[mu_pval_aux]] }}
                                                   {{ com only the ones which can be embeded into the SMT value grammar, so no array literals }}


  term_aux {{ tex term }} :: '' ::= {{ auxparam 'bt }} {{ com terms with auxiliary info }}
    | term ty_bt :: X :: IT
    | term       :: O :: IT_no_aux {{ com Ott-hack for simpler typing rules }}

grammar

  init_t {{ tex init }} , _i {{ tex }} :: '' ::= {{ ocaml bool }} {{ phantom }} {{ com initialisation status }}
    | tick :: :: init   {{ ocaml true  }}                     {{ com initialised  }}
    |  *   :: :: uninit {{ ocaml false }} {{ tex { [[*]] } }} {{ com uninitalised }}

grammar

  points_to :: '' ::= {{ ocaml type points_to = { pointer: 'bt term; perm : int * int; init: bool; ct = Sctypes.t; pointee : 'bt term; } }}
                      {{ phantom }} {{ com arbitrary predicate }}
    | term_aux1 ( rational )|- init_t - ct -> term_aux2 :: :: Points_to
      {{ tex [[term_aux1]] \mathbin{ [[rational]] { \overset{ [[init_t]] }{ \mapsto } }_{ [[ct]] } } [[term_aux2]] }}
      {{ ocaml { pointer = [[term_aux1]] ; perm = [[rational]] ; init = [[init_t]] ; ct = [[ct]] ; pointee = [[term_aux2]] ; } }}

grammar

  resource :: 'Res_' ::= {{ com resources }}
    | emp                                      ::   :: Empty        {{ com empty heap             }}
    | points_to                                ::   :: Points_to    {{ com points-top heap pred.  }}
    | resource1 *s resource2                   ::   :: SepConj      {{ com seperating conjunction }}
    | exists Symbol_sym : base_type . resource ::   :: Exists       {{ com existential            }}
    | term_aux /\ resource                     ::   :: Term         {{ com logical conjuction     }}
    | <( resource )>                           :: S :: Paren        {{ com parentheses            }} {{ ocaml [[resource]] }}
    | [ mu_pval_aux / Symbol_sym ] resource    :: M :: Substitution {{ ocaml RESOURCE_SUB [[mu_pval_aux]] [[Symbol_sym]] [[resource]] }}
                                                                    {{ com substitute $[[mu_pval_aux]]$ for $[[Symbol_sym]]$ in $[[resource]]$ }}


grammar
 
   ret , _r {{ tex \_ }} :: RetTy_ ::= {{ com return types }}
    | sigma tyvar_sym : base_type . ret  :: :: Computational
    | exists tyvar_sym : base_type . ret :: :: Logical
    | resource *s ret                    :: :: Resource
    | term_aux /\ ret                    :: :: Constraint
    | I                                  :: :: I
    | [ spine_elem / tyvar_sym ] ret     :: M :: Substitution {{ ocaml RET_SPINE_ELEM_SUB [[spine_elem]] [[tyvar_sym]] [[ret]] }}


grammar

  % There used to be an effectful value (mu_val) `skip' - I (dcm41) removed it because it seemed redundant.
  mu_seq_expr {{ tex seq\_expr }} :: 'M_Seq_E' ::= {{ auxparam 'TY }} {{ com sequential (effectful) expressions }}
    | mu_pexpr_aux                                                 :: :: pexpr  {{ com pure expressions }}
    | ccall ( ty_act , mu_pval_aux , </ spine_elemi // , // i /> ) :: :: ccall  {{ com C function call  }}
    | pcall ( mu_name , </ spine_elemi // , // i /> )              :: :: proc   {{ com procedure call   }}


  mu_seq_expr_aux {{ tex seq\_expr }} :: 'M_Seq_' ::= {{ auxparam 'TY }} {{ com sequential (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_seq_expr :: X :: expr
    |               mu_seq_expr :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_seq_texpr {{ tex seq\_texpr }} :: 'M_Seq_TE' ::= {{ auxparam 'TY }} {{ com sequential top-level (effectful) expressions }}
    | mu_tval                                                           :: :: tval  {{ com (effectful) top-level values   }}
    | run Symbol_sym mu_pval_aux1 , .. , mu_pval_auxn                   :: :: run   {{ com run from label                 }}
    | nd ( mu_pval_aux1 , .. , mu_pval_auxn )                           :: :: nd    {{ com nondeterministic choice        }}
    | let </ ret_patterni // , // i /> = mu_seq_expr_aux in mu_texpr    :: :: let   {{ com bind return patterns           }} % TODO: bindings
    | let </ ret_patterni // , // i /> : ret = mu_texpr1 in mu_texpr2   :: :: letT  {{ com annotated bind return patterns }} % TODO: bindings
    | case mu_pval_aux of </ | mu_pattern_auxi => mu_texpri // i /> end :: :: case  {{ com pattern matching               }} % TODO: bindings
    | if mu_pval_aux then mu_texpr1 else mu_texpr2                      :: :: if    {{ com conditional                    }}
    | bound [ ty_int ] ( mu_is_texpr_aux )                              :: :: bound {{ com limit scope of indet seq behaviour, absent at runtime }}


  mu_seq_texpr_aux {{ tex seq\_texpr }} :: 'M_Seq_T' ::= {{ auxparam 'TY }} {{ com sequential top-level (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_seq_texpr :: X :: expr
    |               mu_seq_texpr :: O :: seq_no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_is_expr {{ tex is\_expr }} :: 'M_Is_E' ::= {{ auxparam 'TY }} {{ com indet seq (effectful) expressions }}
    | memop ( mu_memop )                   :: :: memop  {{ com pointer op involving memory }}
    | mu_paction                           :: :: action {{ com memory action               }}
    % TODO: require annotation
    | unseq ( mu_texpr1 , .. , mu_texprn ) :: :: unseq {{ com unsequenced expressions }}


  mu_is_expr_aux {{ tex is\_expr }} :: 'M_Is_' ::= {{ auxparam 'TY }} {{ com indet seq (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_is_expr :: X :: expr
    |               mu_is_expr :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_is_texpr {{ tex is\_texpr }} :: 'M_is_TE' ::= {{ auxparam 'TY }} {{ com indet seq top-level (effectful) expressions }}
    | let weak mu_pattern_aux = mu_is_expr_aux in mu_texpr_aux       :: :: wseq  {{ com weak sequencing   }} % TODO: bindings
    | let strong mu_sym_or_pattern = mu_is_expr_aux in mu_texpr_aux  :: :: sseq  {{ com strong sequencing }} % TODO: bindings


  mu_is_texpr_aux {{ tex is\_texpr }} :: 'M_Is_T' ::= {{ auxparam 'TY }} {{ com indet seq top-level (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_is_texpr :: X :: expr
    |               mu_is_texpr :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_texpr {{ tex texpr }} :: 'M_TE' ::= {{ auxparam 'TY }} {{ com top-level (effectful) expressions }}
    | mu_seq_texpr_aux    ::   :: Seq {{ com sequential (effectful) expressions }}
    | mu_is_texpr_aux     ::   :: IS  {{ com indet seq (effectful) expressions  }}
    | [ C / C' ] mu_texpr :: M :: contextSub {{ ocaml MU_TPEXPR_CONTEXT_SUB [[C]] [[C']] [[mu_texpr]] }}
                                             {{ com simul-sub all vars in $[[C]]$ for all vars in $[[C']]$ in $[[mu_texpr]]$ }}

% TODO substitutions

grammar

  terminals :: 'terminals_' ::=
    | \      :: :: lambda    {{ tex \lambda                          }}
    | -->    :: :: red       {{ tex \longrightarrow                  }}
    |  ->    :: :: arrow     {{ tex \rightarrow                      }}
    |  ~>    :: :: leadsto   {{ tex \leadsto                         }}
    |  =>    :: :: synths    {{ tex \Rightarrow                      }}
    |  <=    :: :: checks    {{ tex \Leftarrow                       }}
    | |-     :: :: turnstile {{ tex \vdash                           }}
    | inEnv  :: :: inEnv     {{ tex \in                              }}
    | pi     :: :: pi        {{ tex \Pi                              }}
    | forall :: :: forall    {{ tex \forall                          }}
    | --o    :: :: lollipop  {{ tex \multimap                        }}
    | -)     :: :: implies   {{ tex \supset                          }}
    | sigma  :: :: sigma     {{ tex \Sigma                           }}
    | exists :: :: exists    {{ tex \exists                          }}
    | *s     :: :: star      {{ tex \star                            }}
    | *      :: :: times     {{ tex \times                           }}
    | /\     :: :: and       {{ tex \wedge                           }}
    | /\\    :: :: big_and   {{ tex \bigwedge                        }}
    | neg    :: :: neg       {{ tex \neg                             }}
    | =      :: :: eq        {{ tex =                                }}
    | <>     :: :: neq       {{ tex \neq                             }}
    | =<     :: :: lte       {{ tex \leq                             }}
    | >=     :: :: gte       {{ tex \geq                             }}
    | &      :: :: ampersand {{ tex \ \&                             }}
    | cdot   :: :: cdot      {{ tex \cdot                            }}
    | |      :: :: bar       {{ tex \mid                             }}
    | +ptr   :: :: addptr    {{ tex \mathbin{ {+}_{ \mathrm{ptr} } } }}
    | |->    :: :: mapsto    {{ tex \mapsto                          }}
    | ast    :: :: ast       {{ tex \ast                             }}
    | cons   :: :: cons      {{ tex ::                               }}
    | tick   :: :: tick      {{ tex \checkmark                       }}
    | :      :: :: of_type   {{ tex {:}                              }}
    | .      :: :: such_that {{ tex . \:                             }}
    | dot    :: :: dot       {{ tex .                                }}
    | >>     :: :: chevron   {{ tex \mathbin{ {>} \! \! {>} }        }}
    | :;     :: :: doublecol {{ tex \mathbin{ {:} {:} }              }}
    | ^      :: :: caret     {{ tex \mathbin { \texttt{\char`\^} }   }}
    | \//    :: :: big_or    {{ tex \bigvee                          }}
    | ==     :: :: equiv     {{ tex \equiv                           }}
    | <(     :: :: langle    {{ tex \langle                          }}
    | )>     :: :: rangle    {{ tex \rangle                          }}


grammar

  Z_t {{ tex z }} :: 'Z_' ::= {{ ocaml Z.t }} {{ phantom }} {{ com OCaml arbitrary-width integer }}
    | z_one                       :: X M :: One        {{ ocaml Z.one  }} {{ tex 1                     }}
    | z_zero                      :: X M :: Zero       {{ ocaml Z.zero }} {{ tex 0                     }}
    | i                           :: M :: of_index   {{ ocaml OF_INDEX [[i]]                         }}
                                                     {{ com literal integer                          }}
    | to_int ty_mem_int           :: M :: of_mem_ptr {{ ocaml Memory.integer_value_to_num            }}
                                                     {{ tex \mathrm{to\_int}( [[ty_mem_int]] )       }}
    | size_of ct                  :: M :: of_Ctype   {{ ocaml z_ ( Memory.size_of_ctype ( [[ct]] ) ) }}
                                                     {{ tex \mathrm{size\_of}( [[ct]] )              }}
                                                     {{ com size of a C type                         }}
    | offset_of ty_tag Symbol_identifier :: M :: of_Member
      {{ ocaml z_ ( Memory.member_offset ( ?? [[ty_tag]] ) ( [[Symbol_identifier]] ) ) }}
      {{ tex \mathrm{offset\_of}_{ [[ty_tag]] }( [[Symbol_identifier]] )               }}
      {{ com offset of a struct member                                                 }}
    | ptr_size                    :: M :: Ptr_size   {{ ocaml Memory.size_of_pointer                 }}
                                                     {{ com size of a pointer                        }}
    | max_int ct                  :: M :: of_Max_Int {{ ocaml z_ ( Memory.max_integer_type ( [[ct]] ) ) }}
                                                     {{ tex \mathrm{max\_int}_{ [[ct]] }                }}
                                                     {{ com maximum value of int of type $[[ct]]$       }}
    | min_int ct                  :: M :: of_Min_Int {{ ocaml z_ ( Memory.min_integer_type ( [[ct]] ) ) }}
                                                     {{ tex \mathrm{min\_int}_{ [[ct]] }                }}
                                                     {{ com minimum value of int of type $[[ct]]$       }}


grammar

  rational {{ tex \mathbb{Q} }} :: 'Q_' ::= {{ ocaml ( int * int ) }} {{ phantom }} {{ com OCaml type for rational numbers }}
    | q_one             :: X :: One {{ ocaml (1, 1) }} {{ tex 1 }}
    | ty_int1 / ty_int2 ::   :: Frac {{ ocaml ( [[ty_int1]], [[ty_int2]] ) }} {{ tex \frac{[[ty_int1]]}{[[ty_int2]]} }}

grammar

  lit :: 'Lit_' ::=
    | Symbol_sym ::   :: Sym
    | unit       ::   :: Unit
    | ty_bool    ::   :: Bool
    | Z_t        ::   :: Z
    | rational   ::   :: Q


metavar ty_bt {{ tex }} ::= {{ ocaml 'bt }} {{ phantom }}
  {{ com Ott-hack, ignore (OCaml type variable bt) }}

grammar

  arg :: ArgTy_ ::= {{ com argument/function types }}
    | pi tyvar_sym : base_type . arg     :: :: Computational
    | forall tyvar_sym : base_type . arg :: :: Logical
    | resource --o arg                   :: :: Resource
    | term_aux -) arg                    :: :: Constraint
    | ret                                :: :: Ret
    | [ spine_elem / tyvar_sym ] arg     :: M :: Substitution {{ ocaml ARG_SPINE_ELEM_SUB [[spine_elem]] [[tyvar_sym]] [[arg]] }}


  pure_arg :: Pure_ArgTy_ ::= {{ com pure argument/function types }}
    | pi tyvar_sym : base_type . pure_arg  :: :: Computational
    | term_aux -) pure_arg                 :: :: Constraint
    | pure_ret                             :: :: Ret


  pure_ret :: Pure_RetTy_ ::= {{ com pure return types }}
    | sigma tyvar_sym : base_type . pure_ret :: :: Computational
    | term_aux /\ pure_ret                   :: :: Constraint
    | I                                      :: :: I


  subrules
    pure_arg <:: arg
    pure_ret <:: ret


grammar

  C {{ tex \mathcal{C} }} :: Comp_ ::= {{ phantom }} {{ com computational var env }}
    | cdot                  ::   :: empty
    | C , Symbol_sym : BT_t ::   :: cons
    | </ Ci // , // i />    ::   :: concat
    | fresh ( C )           :: M :: fresh {{ tex \mathrm{fresh}( [[C]] )                            }}
                                          {{ ocaml FRESH_COMP_CONTEXT [[C]]                         }}
                                          {{ com identical context except with fresh variable names }}


grammar

  L {{ tex \mathcal{L} }} :: Log_ ::= {{ phantom }} {{ com logical var env }}
    | cdot                  ::   :: empty
    | </ Li // , // i />    ::   :: concat
    | L , Symbol_sym : BT_t ::   :: cons
    | [ C / C' ] L          :: M :: contextSub {{ ocaml LOG_ENV_CONTEXT_SUB [[C]] [[C']] [[L]] }}


grammar

  N {{ tex \Phi }} :: Con_ ::= {{ phantom }} {{ com constraints env }}
    | cdot                 ::   :: empty
    | N , term_aux         ::   :: cons
    | </ Ni // , // i />   ::   :: concat
    | [ C / C' ] N         :: M :: contextSub {{ ocaml CON_ENV_CONTEXT_SUB [[C]] [[C']] [[N]] }}


grammar

  R {{ tex \mathcal{R} }} :: Res_ ::= {{ phantom }} {{ com resources env }}
    | cdot                      ::   :: empty
    | R , Symbol_sym : resource ::   :: cons
    | R1 , R2                   ::   :: concat
    | [ C / C' ] R              :: M :: contextSub {{ ocaml RES_ENV_CONTEXT_SUB [[C]] [[C']] [[R]] }}


grammar

  formula :: 'formula_' ::=
    | judgement                                                                        :: :: judgement
    | abbrev == term_aux                                                               :: :: abbreviations
    | smt ( N => term_aux )                                                            :: :: smt
    | Symbol_sym : base_type inEnv C                                                   :: :: x_in_C
    | Symbol_sym : struct ty_tag & </ Symbol_identifieri : T_cti // i /> inEnv Globals :: :: struct_in_globals
    | </ Ci ; Li ; Ni |- ty_mem_valuei => mem base_typei // i />                       :: :: indexed_infer_mem_value       {{ com dependent on memory object model }}
    | </ Ci ; Li ; Ni |- mu_pval_auxi => base_typei // i />                            :: :: index_infer_mu_pval
    | mu_name : arg inEnv Globals                                                      :: :: mu_name_in_globals
    | </ term_auxi as mu_pattern_auxi : base_typei ~> Ci ; Ni // i />                  :: :: indexed_pattern
    | </ Ci ; Li ; Ni |- mu_tpexpri <= yi : base_typei . termi // i />                 :: :: indexed_check_mu_tpexpr
    | </ Ci ; Li ; Ni ; Ri |- mu_texpri <= reti // i />                                :: :: indexed_check_mu_texpr
    | L |- logical_val : base_type                                                     :: :: check_logical_value
    | mu_pval_aux : arg inEnv Globals                                                  :: :: mu_pval_aux_in_globals

defns
  object_value_jtype :: '' ::=

  defn
    C ; L ; N |- mu_object_value => obj base_type :: :: Pval_Obj_ :: Pval_Obj_ by


    -------------------------------------- :: Int
    C ; L ; N |- ty_mem_int => obj integer


    ---------------------------------- :: Ptr
    C ; L ; N |- ty_mem_ptr => obj loc


    % only instance of mutually recursive call to mu_value_judgement, can be inlined away
    </ C ; L ; N |- mu_loaded_valuei => base_type // i />
    --------------------------------------------------------------------------- :: Arr
    C ; L ; N |- array ( </ mu_loaded_valuei // i /> ) => obj array base_type


    Symbol_sym : struct ty_tag & </ Symbol_identifieri : T_cti // i /> inEnv Globals
    </ C ; L ; N |- ty_mem_valuei => mem base_typei // i />
    -------------------------------------------------------------------------------- :: Struct
    C ; L ; N |- ( struct ty_tag ) { </ dot Symbol_identifieri : T_cti = ty_mem_valuei //  i /> } => obj struct ty_tag


    % NOT IMPLEMENTED: union
    % UNSUPPORTED: floats

defns
  pval_jtype :: '' ::=

  defn
    C ; L ; N |- mu_pval_aux => base_type :: :: Pval :: Pval_ by


    x : base_type inEnv C
    --------------------------- :: Var
    C ; L ; N |- x => base_type


    % DEFER: impl_const (aka globals) needs resources


    C ; L ; N |- mu_object_value => obj base_type
    --------------------------------------------- :: Obj
    C ; L ; N |- mu_object_value => base_type


    C ; L ; N |- mu_object_value => obj base_type
    --------------------------------------------------- :: Loaded
    C ; L ; N |- specified mu_object_value => base_type


    ------------------------- :: Unit
    C ; L ; N |- Unit => unit


    ------------------------- :: True
    C ; L ; N |- True => bool


    -------------------------- :: False
    C ; L ; N |- False => bool


    </ C ; L ; N |- mu_valuei => base_type // i />
    ----------------------------------------------------------------- :: List
    C ; L ; N |- base_type [ </ mu_valuei // i /> ] => list base_type


    </ C ; L ; N |- mu_valuei =>  base_typei // i />
    -------------------------------------------------------------- :: Tuple
    C ; L ; N |- ( </ mu_valuei // i /> ) => </ base_typei // i />


    % NOT IMPLEMENTED: constrained


    smt ( N => false )
    ----------------------------------------------------------- :: Error
    C ; L ; N |- error ( ty_string , mu_pval_aux ) => base_type


    ------------------------------------------------ :: Ctor_Nil
    C ; L ; N |- Nil base_type ( ) => list base_type


    C ; L ; N |- mu_pval1 => base_type
    C ; L ; N |- mu_pval2 => list base_type
    ---------------------------------------------------------- :: Ctor_Cons
    C ; L ; N |- Cons ( mu_pval1, mu_pval2 ) => list base_type


    </ C ; L ; N |- mu_pvali => base_typei // i />
    ------------------------------------------------------------------- :: Ctor_Tuple
    C ; L ; N |- Tuple ( </ mu_pvali // i /> ) => </ base_typei // i />


    % NOT IMPLEMENTED - empty arrays


    </ C ; L ; N |- mu_pvali => base_type // i />
    ------------------------------------------------------------- :: Ctor_Array
    C ; L ; N |- Array ( </ mu_pvali // i /> ) => array base_type


    C ; L ; N |- mu_pval => base_type
    ----------------------------------------------- :: Ctor_Specified
    C ; L ; N |- Specified ( mu_pval ) => base_type


    </ C ; L ; N |- mu_pvali => base_typei // i />
    ------------------------------------------------------------------------------------------------ :: Struct
    C ; L ; N |- ( struct ty_tag ) { </ dot Symbol_identifieri = mu_pvali // i /> } => struct ty_tag


   % NOT IMPLEMENTED: union

defns
  resource_jtype :: '' ::=

  defn
    resource == resource' :: :: Resource_Eq :: Resource_Eq_ by
    
    -------------------- :: Emp
    emp == emp


    % ASK does this need a context?
    smt ( cdot => ( term_aux1 = term_aux'1 ) /\ ( term_aux2 = term_aux'2 ) )
    -------------------------------------------------------------------------------------------------------- :: PointsTo
    term_aux1 ( rational )|- init_t - ct -> term_aux2 == term_aux'1 ( rational )|- init_t - ct -> term_aux'2


    resource1 == resource'1
    resource2 == resource'2
    -------------------------------------------------- :: SepConj
    resource1 *s resource2 == resource'1 *s resource'2


    resource == resource'
    ------------------------------------------------------------------------------------- :: Exists
    exists Symbol_sym : base_type . resource == exists Symbol_sym : base_type . resource'


    % ASK does this need a context?
    smt ( cdot , term_aux  => term_aux' )
    smt ( cdot , term_aux' => term_aux  )
    resource == resource'
    ---------------------------------------------- :: Term
    term_aux /\ resource == term_aux' /\ resource'


  defn
    C ; L ; N ; R |- res_term <= resource :: :: Resource :: Resource_ by


    ------------------------------ :: Emp
    C ; L ; N ; cdot |- emp <= emp


    ----------------------------------- :: PointsTo
    C ; L ; N ; cdot |- pt <= points_to


    resource == resource'
    ------------------------------------------------- :: Var
    C ; L ; N ; cdot , r : resource |- r <= resource'


    C ; L ; N ; R1 |- res_term1 <= resource1
    C ; L ; N ; R2 |- res_term2 <= resource2
    ---------------------------------------------------------------------------- :: SepConj
    C ; L ; N ; R1 , R2 |- <( res_term1 , res_term2 )> <= resource1 *s resource2


    % Has to be checking. Consider type of pack (1 , l |-> 1 , 1)
    % exists y : integer . l |-> (y,y or y,1 or 1,y or 1,1)
    C ; L ; N |- mu_pval_aux => base_type
    C ; L ; N ; R |- res_term2 <= [ mu_pval_aux / y ] resource
    --------------------------------------------------------------------------------------- :: Pack
    C ; L ; N ; R |- pack ( mu_pval_aux , res_term2 ) <= exists y : base_type . resource


defns
  spine_jtype :: '' ::=

  defn
    C ; L ; N ; R |- </ spine_elemi // , // i /> :; arg >> ret :: :: Spine :: Spine_ by

    --------------------------------- :: Empty
    C ; L ; N ; cdot |- :; ret >> ret


    C ; L ; N |- mu_pval_aux => base_type
    C ; L ; N ; R |- </ spine_elemi // i /> :; [ mu_pval_aux / x ] arg >> ret
    -------------------------------------------------------------------------------------- :: Computational
    C ; L ; N ; R |- mu_pval_aux , </ spine_elemi // i /> :; pi x : base_type . arg >> ret


    L |- logical_val : base_type
    C ; L ; N ; R |- </ spine_elemi // i /> :; [ logical_val / x ] arg >> ret
    ------------------------------------------------------------------------------------------- :: Logical
    C ; L ; N ; R |- logical_val , </ spine_elemi // i /> :;  forall x : base_type . arg >> ret


    C ; L ; N ; R1 |- res_term <= resource
    C ; L ; N ; R2 |- </ spine_elemi // i /> :; arg >> ret
    ------------------------------------------------------------------------------------ :: Resource
    C ; L ; N ; R1 , R2 |- res_term , </ spine_elemi // i /> :;  resource --o arg >> ret


    smt ( N => term_aux )
    C ; L ; N ; R |- </ spine_elemi // i /> :; arg >> ret
    ------------------------------------------------------------------ :: Constraint
    C ; L ; N ; R |- </ spine_elemi // i /> :;  term_aux -) arg >> ret


defns
  pexpr_jtype :: '' ::=

  defn
    C ; L ; N |- mu_pexpr_aux => ident : base_type . term_aux :: :: PExpr :: PExpr_ by


    C ; L ; N |- mu_pval_aux => base_type
    ----------------------------------------------------------------- :: Val
    C ; L ; N |- mu_pval_aux => y : base_type . y = embed mu_pval_aux


   % NOT IMPLEMENTED - mu_ctor_expr
   % Ivmax       :: :: ivmax       {{ com max integer value              }} % : ctype -> integer
   % Ivmin       :: :: ivmin       {{ com min integer value              }} % : ctype -> integer
   % Ivsizeof    :: :: ivsizeof    {{ com sizeof value                   }} % : ctype -> integer
   % Ivalignof   :: :: ivalignof   {{ com alignof value                  }} % : ctype -> integer
   % IvCOMPL     :: :: ivCOMPL     {{ com bitwise complement             }} % : ctype -> integer -> integer
   % IvAND       :: :: ivAND       {{ com bitwise AND                    }} % : ctype -> integer -> integer -> integer
   % IvOR        :: :: ivOR        {{ com bitwise OR                     }} % : ctype -> integer -> integer -> integer
   % IvXOR       :: :: ivXOR       {{ com bitwise XOR                    }} % : ctype -> integer -> integer -> integer

   % Unsupported
   % Fvfromint   :: :: fvfromint   {{ com cast integer to floating value }} % : integer -> floating
   % Ivfromfloat :: :: ivfromfloat {{ com cast floating to integer value }} % : ctype -> floating -> integer


    C ; L ; N |- mu_pval_aux1 => loc
    C ; L ; N |- mu_pval_aux2 => integer
    ------------------------------------ :: Array_Shift
    C ; L ; N |- array_shift ( mu_pval_aux1 , ct , mu_pval_aux2 ) => y : loc . y = embed mu_pval_aux1 +ptr ( embed mu_pval_aux2 * size_of ct )


    C ; L ; N |- mu_pval_aux => loc
    _ : struct ty_tag & </ Symbol_identifieri : T_cti // i /> inEnv Globals
    ------------------------------------------------------------------------ :: Member_Shift
    C ; L ; N |- member_shift ( mu_pval_aux , ty_tag , Symbol_identifierj ) => y : loc . y = embed mu_pval_aux +ptr offset_of ty_tag Symbol_identifierj


    C ; L ; N |- mu_pval_aux => bool
    ------------------------------------------------------------------------ :: Not
    C ; L ; N |- not ( mu_pval_aux ) => y : bool . y = neg embed mu_pval_aux


    C ; L ; N |- mu_pval_aux1 => integer
    C ; L ; N |- mu_pval_aux2 => integer
    --------------------------------------------------------------------------------------------------------------------------------- :: Arith_Binop
    C ; L ; N |- mu_pval_aux1 arith_binop mu_pval_aux2 => y : integer . y = ( embed mu_pval_aux1 ' arith_binop ' embed mu_pval_aux2 )


    C ; L ; N |- mu_pval_aux1 => integer
    C ; L ; N |- mu_pval_aux2 => integer
    -------------------------------------------------------------------------------------------------------------------------- :: Rel_Binop
    C ; L ; N |- mu_pval_aux1 rel_binop mu_pval_aux2 => y : bool . y = ( embed mu_pval_aux1 ' rel_binop ' embed mu_pval_aux2 )


    C ; L ; N |- mu_pval_aux1 => bool
    C ; L ; N |- mu_pval_aux2 => bool
    ---------------------------------------------------------------------------------------------------------------------------- :: Bool_Binop
    C ; L ; N |- mu_pval_aux1 bool_binop mu_pval_aux2 => y : bool . y = ( embed mu_pval_aux1 ' bool_binop ' embed mu_pval_aux2 )


    mu_name : pure_arg inEnv Globals
    C ; L ; N ; cdot |- </ mu_pval_auxi // i /> :; pure_arg >> sigma y' : base_type' . term' /\ I
    --------------------------------------------------------------------------------------------- :: Call
    C ; L ; N |- mu_name ( </ mu_pval_auxi // i /> ) => y' : base_type' . term'


    % DEFER conv_int
    % conv_int ( ty_act , mu_pval_aux )


    C ; L ; N |- mu_pval_aux => bool
    smt ( N => embed mu_pval_aux )
    --------------------------------------------------------------------------------- :: Assert_Undef
    C ; L ; N |- assert_undef ( mu_pval_aux , ty_loc UB_name ) => y : unit . y = unit


    C ; L ; N |- mu_pval_aux => bool
    ------------------------------------------------------------------------------------------------------------- :: Bool_To_Integer
    C ; L ; N |- bool_to_integer ( mu_pval_aux ) => y : integer . y = if embed mu_pval_aux then z_one else z_zero


    C ; L ; N |- mu_pval_aux => integer
    abbrev1 == max_int ct - min_int ct + z_one
    abbrev2 == embed mu_pval_aux rem_f abbrev1
    ----------------------------------------------------------------------------------------------------------------------------- :: WrapI
    C ; L ; N |- wrapI ( ct , mu_pval_aux ) => y' : base_type . y = if abbrev2 =< max_int ct then abbrev2 else abbrev2 - abbrev1


defns
  pattern_jtype :: '' ::=

  defn
    term_aux as mu_pattern_aux : base_type ~> C ; N :: :: Comp_Pattern_ :: Comp_Pattern_ by

    ---------------------------------------------------- :: No_Sym_Annot
    term_aux as _ : base_type : base_type ~> cdot ; cdot


    ----------------------------------------------------------------------------------- :: Sym_Annot
    term_aux as x : base_type : base_type ~> cdot , x : base_type ; cdot , x = term_aux


    ------------------------------------------------------------- :: Nil
    term_aux as Nil base_type ( ) : list base_type ~> cdot ; cdot


    i_one th_l term_aux as mu_pattern_aux1 : base_type ~> C1 ; N1
    tl term_aux as mu_pattern_aux2 : list base_type ~> C2 ; N1
    -------------------------------------------------------------------------------------------- :: Cons
    term_aux as Cons ( mu_pattern_aux1 , mu_pattern_aux2 ) : list base_type ~> C1 , C2 ; N1 , N2


    </ i th_t term_aux as mu_pattern_auxi : base_typei ~> Ci ; Ni // i />
    --------------------------------------------------------------------------------------------------------- :: Tuple
    term_aux as Tuple ( </ mu_pattern_auxi // i /> ) : </ base_typei // i /> ~> </ Ci // i /> ; </ Ni // i />


    </ term_aux [ i ] as mu_pattern_auxi : base_type ~> Ci ; Ni // i />
    --------------------------------------------------------------------------------------------------- :: Array
    term_aux as Array ( </ mu_pattern_auxi // i /> ) : array base_type ~> </ Ci // i /> ; </ Ni // i />


    term_aux as mu_pattern_aux : base_type ~> C ; N
    ------------------------------------------------------------- :: Specified
    term_aux as Specified ( mu_pattern_aux ) : base_type ~> C ; N


  defn
    term_aux as mu_sym_or_pattern : base_type ~> C ; N :: :: Sym_Or_Pattern :: Sym_Or_Pattern_ by


    ------------------------------------------------------------------------ :: Sym
    term_aux as x : base_type ~> cdot , x : base_type ; cdot , x = term_aux


    term_aux as mu_pattern_aux : base_type ~> C ; N
    ----------------------------------------------- :: Pattern
    term_aux as mu_pattern_aux : base_type ~> C ; N


  defn
    </ ret_patterni // , // i /> : ret ~> C ; L ; N ; R :: :: Ret_Pattern :: Ret_Pattern_ by


    ------------------------------------------------- :: Empty
     : I ~> cdot ; cdot ; cdot ; cdot


    y as mu_sym_or_pattern : base_type ~> C1 ; N1
    </ ret_patterni // i /> : ret ~> C2 ; L2 ; N2 ; R2
    ----------------------------------------------------------------------------------------------------- :: Computational
    comp mu_sym_or_pattern , </ ret_patterni // i /> : sigma y : base_type . ret ~> C1, C2 ; L2 ; N2 ; R2


    </ ret_patterni // i /> : ret ~> C ; L ; N ; R
    ---------------------------------------------------------------------------------------------- :: Logical
    log y , </ ret_patterni // i /> : exists y : base_type . ret ~> C ; L , y : base_type ; N ; R


    res_pattern : resource ~> L1 ; N1 ; R1
    </ ret_patterni // i /> : ret ~> C2 ; L2 ; N2 ; R2
    -------------------------------------------------------------------------------------------- :: Resource
    res res_pattern , </ ret_patterni // i /> : resource *s ret ~> C2 ; L1, L2 ; N1, N2 ; R1, R2


    </ ret_patterni // i /> : ret ~> C ; L ; N ; R
    --------------------------------------------------------------------- :: Constraint
    </ ret_patterni // i /> : term_aux /\ ret ~> C ; L ; N , term_aux ; R


  defn
    res_pattern : resource ~> L ; N ;  R :: :: Res_Pattern :: Res_Pattern_ by


    -------------------------------- :: Empty
    emp : emp ~> cdot ; cdot ; cdot


    ---------------------------------------------------- :: PointsTo
    pt : points_to ~> cdot ; cdot ; cdot , r : points_to


    ------------------------------------------------- :: Var
    r : resource ~> cdot ; cdot ; cdot , r : resource


    res_pattern1 : resource1 ~> L1 ; N1 ; R1
    res_pattern2 : resource2 ~> L2 ; N2 ; R2
    ----------------------------------------------------------------------------------------- :: SepConj
    <( res_pattern1 , res_pattern2 )> : resource1 *s resource2 ~> L1 , L2 ; N1 , N2 ; R1 , R2


    res_pattern : resource ~> L ; N ; R
    ---------------------------------------------------------- :: Conj
    res_pattern : term_aux /\ resource ~> L ; N , term_aux ; R


    res_pattern : [ x / y ] resource ~> L ; N ; R
    --------------------------------------------------------------------------------------- :: Pack
    pack ( x , res_pattern ) : exists y : base_type . resource ~> L , x : base_type ; N ; R


defns
  tpval_jtype :: '' ::=

  defn
    C ; L ; N |- mu_tpval_aux <= ident : base_type . term_aux :: :: TPVal :: TPVal_ by


    smt ( N => false )
    ------------------------------------------------------------- :: Undef
    C ; L ; N |- undef ty_loc UB_name <= y : base_type . term_aux


    C ; L ; N |- mu_pval_aux => base_type
    smt ( N => term )
    ----------------------------------------------------- :: Done
    C ; L ; N |- done mu_pval_aux <= y : base_type . term


defns
  tpexpr_jtype :: '' ::=

  defn
    C ; L ; N |- mu_tpexpr_aux <= ident : base_type . term_aux :: :: TPExpr :: TPExpr_ by


    % No need for propogating constraints
    C ; L ; N |- mu_pval_aux => bool
    C ; L ; N , embed mu_pval_aux = true  |- mu_tpexpr_aux1 <= y : base_type . term
    C ; L ; N , embed mu_pval_aux = false |- mu_tpexpr_aux2 <= y : base_type . term
    -------------------------------------------------------------------------------------------- :: If
    C ; L ; N |- if mu_pval_aux then mu_tpexpr_aux1 else mu_tpexpr_aux2 <= y : base_type . term


    % A simplified rule for understanding.
    % x is renamed to prevent shadowing from resulting in inconsistent constraints.
    % e.g. let x = 2 + 2 in let x = 3 in x
    % C ; L ; N |- mu_pexpr_aux => y1 : base_type1 . term1
    % C , x1 : base_type1 ; L , y1 : base_type1 ; N , term1 , y1 = x1 |- [ x1 / x ] mu_tpexpr <= y2 : base_type2 . term2
    % ------------------------------------------------------------------------------------------------------------------ :: Let
    % C ; L ; N |- let x = mu_pexpr_aux in mu_tpexpr <= y2 : base_type2 . term2


    C ; L ; N |- mu_pexpr_aux => y1 : base_type1 . term1
    y1 as mu_sym_or_pattern : base_type1 ~> C1 ; N1
    C , fresh ( C1 ) ; L , y1 : base_type1 ; N , term1 , [ fresh ( C1 ) / C1 ] N1 |- [ fresh ( C1 ) / C1 ] mu_tpexpr <= y2 : base_type2 . term2
    ------------------------------------------------------------------------------------------------------------------------------------------- :: Let
    C ; L ; N |- let mu_sym_or_pattern = mu_pexpr_aux in mu_tpexpr <= y2 : base_type2 . term2


    C ; L ; N |- mu_pval_aux => base_type1
    </ y1 as mu_patterni : base_type1 ~> Ci ; Ni // i />
    </ C , fresh ( Ci ) ; L , y1 : base_type1 ; N , y1 = embed mu_pval_aux , [ fresh ( Ci ) / Ci ] Ni |- [ fresh ( Ci ) / Ci ] mu_tpexpri <= y2 : base_type2 . term2 // i />
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ :: Case
    C ; L ; N |- case mu_pval_aux of </ | mu_patterni => mu_tpexpri // i /> end <= y2 : base_type2 . term2


defns
  action_jtype :: '' ::=

  defn
    C ; L ; N ; R |- mu_action_aux => ret :: :: Action :: Action_ by


    C ; L ; N |- mu_pval_aux => integer
    ----------------------------------- :: Create
    C ; L ; N ; cdot |- create ( mu_pval_aux , ct ) Symbol_prefix => sigma yp : loc . exists y : to_base ( ct ) . representable ( ct ast , yp ) /\ alignedI ( embed mu_pval_aux , yp ) /\ <( yp ( q_one )|- * - ct -> y )> *s I


    % NOT IMPLEMENTED:
    % C ; L ; N ; cdot |-> create_readonly ( vp , ct , v ) Symbol_prefix => ??


    C ; L ; N |- mu_pval_aux1 => loc
    C ; L ; N |- mu_pval_aux2 => to_base ( ct )
    % NOT IMPLEMENTED: locking boolean
    smt ( N => representable ( ct , embed mu_pval_aux2 ) )
    smt ( N => embed mu_pval_aux0 = embed mu_pval_aux1 )
    -------------------------------------------------------- :: Store
    C ; L ; N ; cdot , r : <( embed mu_pval_aux0 ( q_one )|- _i - ct -> _t )> |- store ( _b , ct , mu_pval_aux1 , mu_pval_aux2 , _mem_order ) => sigma _ : unit . embed mu_pval_aux0 ( q_one )|- tick - ct -> embed mu_pval_aux2 *s I


    C ; L ; N |- mu_pval_aux1 => loc
    smt ( N => embed mu_pval_aux0 = embed mu_pval_aux1 )
    ---------------------------------------------------- :: Kill_Static
    C ; L ; N ; cdot , r : <( embed mu_pval_aux0 ( q_one )|- _i - ct -> _t )> |-  kill ( static ct , mu_pval_aux1 ) => sigma _ : unit . I


    % NOT IMPLEMENTED:
    % C ; L ; N ; ?? |- kill ( dynamic , v ) => ??


    % mu_action_aux {{ tex action\_aux }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions }}
    %   | alloc ( ty_asym1 , ty_asym2 ) Symbol_prefix                                                         :: :: Alloc
    %   | load ( ty_act , ty_asym , Cmm_memory_order )                                                        :: :: Load
    %   | rmw ( ty_act ,  ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )            :: :: RMW
    %   | fence ( Cmm_memory_order )                                                                          :: :: Fence
    %   | cmp_exch_strong ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: CompareExchangeStrong
    %   | cmp_exch_weak ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )   :: :: CompareExchangeWeak
    %   | linux_fence ( Linux_linux_memory_order )                                                            :: :: LinuxFence
    %   | linux_load ( ty_act , ty_asym , Linux_linux_memory_order )                                          :: :: LinuxLoad
    %   | linux_store ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                             :: :: LinuxStore
    %   | linux_rmw ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                               :: :: LinuxRMW


defns
  tval_jtype :: '' ::=

  defn
    C ; L ; N ; R |- mu_tval_aux <= ret :: :: TVal :: TVal_ by

    -------------------------- :: I
    C ; L ; N ; R |- done <= I


    C ; L ; N |- mu_pval_aux => base_type
    C ; L ; N ; R |- done </ spine_elemi // i /> <= [ mu_pval_aux / y ] ret
    --------------------------------------------------------------------------------------- :: Computational
    C ; L ; N ; R |- done mu_pval_aux , </ spine_elemi // i /> <= sigma y : base_type . ret


    L |- logical_val : base_type
    C ; L ; N ; R |- done </ spine_elemi // i /> <= [ logical_val / y ] ret
    ----------------------------------------------------------------------------------------- :: Logical
    C ; L ; N ; R |- done logical_val , </ spine_elemi // i /> <= exists y : base_type . ret


    smt ( N => term_aux )
    C ; L ; N ; R |- done </ spine_elemi // i /> <= ret
    --------------------------------------------------------------- :: Constraint
    C ; L ; N ; R |- done </ spine_elemi // i /> <= term_aux /\ ret


    C ; L ; N ; R1 |- res_term <= resource
    C ; L ; N ; R2 |- done </ spine_elemi // i /> <= ret
    -------------------------------------------------------------------------------- :: Resource
    C ; L ; N ; R1 , R2 |- done res_term , </ spine_elemi // i /> <= resource *s ret


    smt ( N => false )
    ----------------------------------------------- :: UB
    C ; L ; N ; cdot |- undef ty_loc UB_name <= ret


defns
  texpr_jtype :: '' ::=

  defn
    C ; L ; N ; R |- mu_seq_expr_aux => ret :: :: Seq_Expr :: Seq_Expr_ by


    C ; L ; N |- mu_pexpr_aux => y : base_type . term
    ------------------------------------------------------------------ :: Pure
    C ; L ; N ; cdot |- mu_pval_aux => sigma y : base_type . term /\ I


    C ; L ; N |- mu_pval_aux => loc
    mu_pval_aux : arg inEnv Globals
    C ; L ; N ; R |- </ spine_elemi // i /> :; arg >> ret
    ------------------------------------------------------------------------------- :: CCall
    C ; L ; N ; R |- ccall ( ty_act , mu_pval_aux , </ spine_elemi // i /> ) => ret


    mu_name : arg inEnv Globals
    C ; L ; N ; R |- </ spine_elemi // i /> :; arg >> ret
    ------------------------------------------------------------------ :: Proc
    C ; L ; N ; R |- pcall ( mu_name , </ spine_elemi // i /> ) => ret


  defn
    C ; L ; N ; R |- mu_is_expr_aux => ret :: :: IS_Expr :: IS_Expr_ by

    % TODO
    % memop ( mu_memop )


    C ; L ; N ; R |- mu_action => ret
    ------------------------------------- :: Action
    C ; L ; N ; R |- Pos mu_action => ret


    C ; L ; N ; R |- mu_action => ret
    ------------------------------------- :: Neg_Action
    C ; L ; N ; R |- Neg mu_action => ret

    % TODO unseq ( mu_texpr1 , .. , mu_texprn )

  defn
    C ; L ; N ; R |- mu_seq_texpr_aux <= ret :: :: Seq_TExpr :: Seq_TExpr_ by


    C ; L ; N ; R |- mu_tval <= ret
    -------------------------------- :: TVal
    C ; L ; N ; R |- mu_tval <= ret


    C ; L ; N ; R' |- mu_seq_expr => ret1
    </ ret_patterni // i /> : ret1 ~> C1 ; L1 ; N1 ; R1
    C , fresh ( C1 ) ; L , L1 ; N , [ fresh ( C1 ) / C1 ] N1 ; R , [ fresh ( C1 ) / C1 ] R1 |- [ fresh ( C1 ) / C1 ] mu_texpr <= ret
    -------------------------------------------------------------------------------------------------------------------------------- :: Let
    C ; L ; N ; R' , R |- let </ ret_patterni // i /> = mu_seq_expr in mu_texpr <= ret


    C ; L ; N ; R' |- mu_texpr1 <= ret1
    </ ret_patterni // i /> : ret1 ~> C1 ; L1 ; N1 ; R1
    C , fresh ( C1 ) ; L , L1 ; N , [ fresh ( C1 ) / C1 ] N1 ; R , [ fresh ( C1 ) / C1 ] R1 |- [ fresh ( C1 ) / C1 ] mu_texpr2 <= ret2
    ---------------------------------------------------------------------------------------------------------------------------------- :: LetT
    C ; L ; N ; R' , R |- let </ ret_patterni // i /> : ret1 = mu_texpr1 in mu_texpr <= ret2


    C ; L ; N |- mu_pval_aux => base_type1
    </ y1 as mu_patterni : base_type1 ~> Ci ; Ni // i />
    </ C , fresh ( Ci ) ; L , y1 : base_type1 ; N , y1 = embed mu_pval_aux , [ fresh ( Ci ) / Ci ] Ni ; R |- [ fresh ( Ci ) / Ci ] mu_texpri <= ret // i />
    ------------------------------------------------------------------------------------------------------------------------------------------------------- :: Case
    C ; L ; N ; R |- case mu_pval_aux of </ | mu_patterni => mu_texpri // i /> end <= ret


    C ; L ; N |- mu_pval_aux => bool
    C ; L ; N , embed mu_pval_aux = true  ; R1 |- mu_texpr1 <= ret
    C ; L ; N , embed mu_pval_aux = false ; R2 |- mu_texpr2 <= ret
    -------------------------------------------------------------------------- :: If
    C ; L ; N ; R1 , R2 |- if mu_pval_aux then mu_texpr1 else mu_texpr2 <= ret


    % TODO
    % run Symbol_sym mu_pval_aux1 , .. , mu_pval_auxn
    % nd ( mu_pval_aux1 , .. , mu_pval_auxn )
    % bound [ ty_int ] ( mu_is_texpr_aux )


  defn
    C ; L ; N ; R |- mu_is_texpr_aux <= ret :: :: IS_TExpr :: IS_TExpr_  by


    % TODO
    % let weak mu_pattern_aux = mu_is_expr_aux in mu_texpr_aux
    % let strong mu_sym_or_pattern = mu_is_expr_aux in mu_texpr_aux


  defn
    C ; L ; N ; R |- mu_texpr <= ret :: :: TExpr :: TExpr_ by

