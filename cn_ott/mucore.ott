% NB the comments here relate to the Core source syntax; the Lem
% datatypes have additional values used at Core runtime

embed {{ tex-preamble
%\usepackage[scaled=0.82]{beramono}
\geometry{landscape}
\renewcommand{\ottkw}[1]{ \texttt{#1} }
}}

metavar ty_tag {{ tex tag }} {{ ocaml tag }} ::=
  {{ phantom }} {{ com OCaml type for struct/union tag }}

grammar

  base_type {{ tex \beta }} :: '' ::=                  {{ com Core base types   }}
    | unit                                      :: :: Unit    {{ com unit              }}
    | bool                                      :: :: Bool    {{ com boolean           }}
    | integer                                   :: :: Integer {{ com integer           }}
    | real                                      :: :: Read    {{ com rational numbers? }}
    | loc                                       :: :: Loc     {{ com location          }}
    | array base_type                           :: :: Array   {{ com array             }}
    | [ base_type ]                             :: :: ListTy  {{ com list              }}
    | ( base_type1 , .. , base_typen )          :: :: TupleTy {{ com tuple             }}
    | struct ty_tag                             :: :: Struct  {{ com struct            }}
    | { base_type }                             :: :: Set     {{ com set               }}
    | opt ( base_type )                         :: :: Option  {{ com option            }}
    | base_type1 , .. , base_typen -> base_type :: :: Param   {{ com parameter types   }}

grammar

  % Binary operators
  binop :: 'Op' ::= {{ ocaml Core.binop }} {{ phantom }} {{ com binary operators }}
    % arithmetic operators (integer -> integer -> integer)
    | +     :: :: Add {{ tex \texttt{+} }} {{ com addition       }}
    | -     :: :: Sub {{ tex \texttt{-} }} {{ com subtraction    }}
    | *     :: :: Mul {{ tex \texttt{*} }} {{ com multiplication }} 
    | /     :: :: Div {{ tex \texttt{/} }} {{ com division       }}
    | rem_t :: :: Rem_t                    {{ com modulus }}
    | rem_f :: :: Rem_f                    {{ com remainder }}
    | ^     :: :: Exp {{ tex \texttt{\char`^}   }} {{ com exponentiation }}
    % relational operators
    | =     :: :: Eq {{ tex \texttt{=}  }} {{ com equality, defined both for integer and C types }}
    | >     :: :: Gt {{ tex \texttt{>}  }} {{ com greater than }}
    | <     :: :: Lt {{ tex \texttt{<}  }} {{ com less than }}
    | >=    :: :: Ge {{ tex \texttt{>=} }} {{ com greater than or equal to }}
    | <=    :: :: Le {{ tex \texttt{<=} }} {{ com less than or equal to }}
    % logical connectives
    | /\    :: :: And {{ tex \texttt{/\char`\\} }} {{ com conjucntion }}
    | \/    :: :: Or  {{ tex \texttt{\char`\\/} }} {{ com disjunction }}


grammar

  polarity :: '' ::= {{ ocaml Core.polarity }} {{ phantom }} {{ com memory action polarities }}
    | Pos :: :: Pos {{ com sequenced by \ottkw{let\ weak} and \ottkw{let\ strong} }}
    | Neg :: :: Neg {{ com only sequenced by \ottkw{let\ strong} }}


metavar impl_const
  {{ ocaml Implementation.implementation_constant }} ::=
  {{ phantom }} {{ com implementation-defined constant }}

metavar x , y , tyvar_sym {{ ocaml 'sym }} {{tex ident }} ::=
  {{ phantom }} {{ com OCaml type variable for symbols }}

grammar

  % TODO binders
  Symbol_sym {{ tex ident }} :: '' ::= {{ ocaml Symbol.sym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | tyvar_sym :: X :: Tyvar_Sym
    | ty_tag    :: X :: Tag


grammar

  mu_name {{ tex name }} :: '' ::= {{ ocaml Symbol.sym Core.generic_name }} {{ phantom }}
    | Symbol_sym :: :: Sym  {{ com Core identifier                 }} 
    | impl_const :: :: Impl {{ com implementation-defined constant }}

metavar ty_mem_int {{ ocaml Impl_mem.integer_value }} ::=
    {{ phantom }}  {{ com memory integer value }}

metavar ty_mem_value {{ ocaml Impl_mem.mem_value }} {{ tex mem\_val }} ::=
    {{ phantom }} {{ com memory value }}

metavar Symbol_identifier {{ tex member }} {{ ocaml Symbol.identifier }} ::=
   {{ phantom }} {{ com C struct/union member name }}

metavar T_ct {{ tex \tau }} {{ ocaml T.ct }} ::=
    {{ phantom }} {{ com C type }}

% TODO hide from Tex
metavar annots {{ ocaml annot list }} ::=
  {{ phantom }} {{ com annotations }}

metavar ty_nat {{ tex nat }} {{ ocaml Nat_big_num.num }} ::=
  {{ phantom }} {{ com OCaml arbitrary-width natural number }}

indexvar n, i ::= {{ phantom }} {{ com index variables }}

grammar

  ptrval :: 'PV' ::= {{ phantom }} {{ ocaml Impl_mem.pointer_value }} {{ com pointer values }}
    | nullptr            :: :: null       {{ com null pointer }}
    | funcptr Symbol_sym :: :: function   {{ com function pointer }}
    | concptr ty_nat     :: :: concrete   {{ com concrete pointer }}

grammar

% (* Object values (inhabitants of object types, hence values that can be read/stored) *)
  mu_object_value {{ tex object\_value }} :: 'M_OV' ::=  {{ auxparam 'TY }} {{ com C object values }} 
    | ty_mem_int                                                                                :: :: integer {{ com integer value  }}
    | ptrval                                                                                    :: :: pointer {{ com pointer value  }}
    | array ( mu_loaded_value1 , .. , mu_loaded_valuen )                                        :: :: array   {{ com C array value  }}
    | ( struct Symbol_sym ) { </ . Symbol_identifieri : T_cti = ty_mem_valuei // , // i /> }    :: :: struct  {{ com C struct value }}
    | ( union Symbol_sym ) { . Symbol_identifier = ty_mem_value }                               :: :: union   {{ com C union value  }}
  

  mu_loaded_value {{ tex loaded\_value }} :: 'M_LV' ::= {{ auxparam 'TY }} {{ com potentially unspecified C object values }}
    | specified ( mu_object_value ) :: :: specified {{ com specified loaded value }}
  

grammar

  T_bt {{ tex \beta }} :: 'T_bt_' ::= {{ ocaml T.bt }} {{ phantom }} {{ com Ott-hack, ignore }}
    | base_type :: X :: BaseType


grammar

  mu_value {{ tex value }} :: 'M_V' ::= {{ auxparam 'TY }} {{ com Core values }}
    | mu_object_value                     :: :: object {{ com C object value        }} 
    | mu_loaded_value                     :: :: loaded {{ com loaded C object value }}
    | Unit                                :: :: unit   {{ com unit                  }}
    | True                                :: :: true   {{ com boolean true          }}
    | False                               :: :: false  {{ com boolean false         }}
    | T_bt [ mu_value1 , .. , mu_valuei ] :: :: list   {{ com list                  }}
    | ( mu_value1 , .. , mu_valuei )      :: :: tuple  {{ com tuple                 }}

grammar

  mu_ctor {{ tex ctor }} :: 'M_C' ::= {{ com data constructors }}
    | Nil T_bt    :: :: nil         {{ com empty list                     }} % : [bTy] 
    | Cons        :: :: cons        {{ com list cons                      }} % : bTy -> [bTy] -> [bTy] 
    | Tuple       :: :: tuple       {{ com tuple                          }} % : bTy1 -> ... -> bTyN -> (bTy1, ..., bTyN) 
    | Array       :: :: array       {{ com C array                        }} % : bTy -> ... -> bTy -> array bTy 
    | Ivmax       :: :: ivmax       {{ com max integer value              }} % : ctype -> integer 
    | Ivmin       :: :: ivmin       {{ com min integer value              }} % : ctype -> integer 
    | Ivsizeof    :: :: ivsizeof    {{ com sizeof value                   }} % : ctype -> integer 
    | Ivalignof   :: :: ivalignof   {{ com alignof value                  }} % : ctype -> integer 
    | IvCOMPL     :: :: ivCOMPL     {{ com bitwise complement             }} % : ctype -> integer -> integer
    | IvAND       :: :: ivAND       {{ com bitwise AND                    }} % : ctype -> integer -> integer -> integer
    | IvOR        :: :: ivOR        {{ com bitwise OR                     }} % : ctype -> integer -> integer -> integer
    | IvXOR       :: :: ivXOR       {{ com bitwise XOR                    }} % : ctype -> integer -> integer -> integer
    | Specified   :: :: specified   {{ com non-unspecified loaded value   }} % : objTy -> loaded objTy 
    | Unspecified :: :: unspecified {{ com unspecified loaded value       }} % : ctype -> loaded (integer|floating|pointer|array|struct|union) 
    | Fvfromint   :: :: fvfromint   {{ com cast integer to floating value }} % : integer -> floating
    | Ivfromfloat :: :: ivfromfloat {{ com cast floating to integer value }} % : ctype -> floating -> integer

metavar ty_loc {{ tex loc }} {{ ocaml Location_ocaml.t }} ::=
  {{ phantom }} {{ com OCaml type for C source }}

grammar

  ty_sym_opt_T_bt {{ tex ident\_opt\_\beta }}:: '' ::= {{ phantom }} {{ ocaml ( Symbol.sym option * T.bt ) }} {{ com type annotated optional identifier }}
    | _ : T_bt          :: :: Nothing % (+ binders = {} +)
    | Symbol_sym : T_bt :: :: Just    % (+ binders = Symbol_sym +)
  

grammar

  mu_pattern_aux {{ tex pattern\_aux }} :: 'M_Case' ::=
    | ty_sym_opt_T_bt                         :: :: Base % (+ binders = binders( maybesym_base_type ) +)
    | mu_ctor ( </ mu_patterni // , // i /> ) :: :: Ctor % (+ binders = binders( </ mu_patterni // , // i /> ) +)


  mu_pattern {{ tex pattern }} :: 'M_' ::=
    | ty_loc annots mu_pattern_aux :: :: Pattern % (+ binders = binders(mu_pattern_aux) +)


grammar

  mu_sym_or_pattern {{ tex ident\_or\_pattern }} :: 'M_' ::= {{ auxparam 'TY }}
    | Symbol_sym :: :: Symbol % (+ binders = Symbol_sym +)
    | mu_pattern :: :: Pat    % (+ binders = binders(mu_pattern_aux) +)


metavar Mem_mem_iv_constraint {{ tex mem\_iv\_c }} {{ ocaml Mem.mem_iv_constraint }} ::=
  {{ phantom }} {{ com OCaml type for memory constraints on integer values }}

metavar UB_name
  {{ ocaml Undefined.undefined_behaviour }} ::=
  {{ phantom }} {{ com undefined behaviour }}

metavar ty_string {{ tex string }} {{ ocaml string }} ::=
  {{ phantom }}
  {{ com OCaml string }}

metavar tyvar_TY {{ ocaml 'TY }} ::=
  {{ phantom }} {{ com OCaml type variable for types }}

metavar ty_act {{ tex \tau }} {{ ocaml 'TY act }} ::=
  {{ phantom }} {{ com OCaml type for an annotated C type }}
  
grammar

  ty_asym {{ tex ident }} :: 'ty_asym_' ::= {{ ocaml 'TY asym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | Symbol_sym :: X :: Symbol_sym


grammar

  mu_pexpr_aux {{ tex pexpr\_aux }} :: 'M_PE' ::= {{ auxparam 'TY }} {{ com pure expressions }}
    | Symbol_sym                                                                :: :: sym
    | impl_const                                                                :: :: impl         {{ com implementation-defined constant           }} 
    | mu_value                                                                  :: :: val
    | constrained ( </ Mem_mem_iv_constrainti , ty_asymi // , // i /> )         :: :: constrained  {{ com constrained value                         }}
    | error ( ty_string , ty_asym )                                             :: :: error        {{ com impl-defined static error                 }}
    | mu_ctor ( </ ty_asymi // , // i /> )                                      :: :: ctor         {{ com data constructor application              }}
    | array_shift ( ty_asym1 , T_ct , ty_asym2 )                                :: :: array_shift  {{ com pointer array shift                       }}
    | member_shift ( ty_asym , Symbol_sym , Symbol_identifier )                 :: :: member_shift {{ com pointer struct/union member shift         }}
    | not ( ty_asym )                                                           :: :: not          {{ com boolean not                               }}
    | ty_asym1 binop ty_asym2                                                   :: :: op           {{ order [[binop]] [[ty_asym1]] [[ty_asym2]] }} {{ com binary operations }}
    | ( struct Symbol_sym ) { </ . Symbol_identifieri = ty_asymi // , // i /> } :: :: struct       {{ com C struct expression                       }}
    | ( union Symbol_sym ) { . Symbol_identifier = ty_asym }                    :: :: union        {{ com C union expression                        }}
    | memberof  ( Symbol_sym , Symbol_identifier , ty_asym )                    :: :: memberof     {{ com C struct/union member access              }}
    | mu_name ( ty_asym1 , .. , ty_asymn )                                      :: :: call         {{ com pure function call                        }}

    | assert_undef ( ty_asym , ty_loc , UB_name )                               :: :: assert_undef
    | bool_to_integer ( ty_asym )                                               :: :: bool_to_integer
    | conv_int ( ty_act , ty_asym )                                             :: :: conv_int
    | wrapI ( ty_act , ty_asym )                                                :: :: wrapI
 

  mu_pexpr {{ tex pexpr }} :: 'M_P' ::= {{ auxparam 'TY }} {{ com pure expressions with location and annotations }}
    | ty_loc annots tyvar_TY mu_pexpr_aux :: :: expr


grammar

 % TODO: binders
  mu_tpexpr_aux {{ tex tpexpr\_aux }} :: 'M_TP' ::= {{ auxparam 'TY }} {{ com top-level pure expressions }}
    | undef ty_loc UB_name                                       ::   :: undef {{ com undefined behaviour }}
    | case ty_asym of </ | mu_patterni => mu_tpexpri // i /> end ::   :: case {{ com pattern matching }}
    | let mu_sym_or_pattern = mu_tpexpr1 in mu_tpexpr2             ::   :: let  {{ com pure let         }}
    | if ty_asym then mu_tpexpr1 else mu_tpexpr2                 ::   :: if   {{ com pure if          }}
    | done ty_asym                                               ::   :: done {{ com pure done        }}

  mu_tpexpr {{ tex tpexpr }} :: 'M_TP' ::= {{ auxparam 'TY }} {{ com pure top-level pure expressions with location and annotations }}
    | ty_loc annots tyvar_TY mu_tpexpr_aux :: :: expr


grammar

  m_kill_kind :: 'M_' ::=
    | dynamic     :: :: Dynamic
    | static T_ct :: :: Static


grammar

  ty_bool :: '' ::=   {{ ocaml bool  }} {{ phantom }} {{ tex bool }} {{ com OCaml booleans }}
    | true  :: :: True  {{ ocaml true  }}
    | false :: :: False {{ ocaml false }}


metavar Symbol_prefix {{ tex sym\_prefix }} {{ ocaml Symbol.prefix }} ::=
  {{ phantom }} {{ com OCaml type for symbol prefix }}

metavar Cmm_memory_order
  {{ tex mem\_order }}
  {{ ocaml Cmm_csem.memory_order }} ::=
  {{ phantom }}
  {{ com OCaml type for memory order }}

metavar Linux_linux_memory_order
  {{ tex linux\_mem\_order }}
  {{ ocaml Linux.linux_memory_order }} ::=
  {{ phantom }}
  {{ com OCaml type for Linux memory order }}

metavar ty_int {{ tex k }} {{ ocaml int }} ::=
  {{ phantom }} {{ com OCaml fixed-width integer }}

grammar

  mu_action_aux {{ tex action\_aux }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions }}
    | create ( ty_asym , ty_act ) Symbol_prefix                                                           :: :: Create
    | create_readonly ( ty_asym1 , ty_act , ty_asym2 ) Symbol_prefix                                      :: :: CreateReadOnly
    | alloc ( ty_asym1 , ty_asym2 ) Symbol_prefix                                                         :: :: Alloc
    | kill ( m_kill_kind , ty_asym )                                                                      :: :: Kill {{ com the boolean indicates whether the action is dynamic (i.e. free()) }}
    | store ( ty_bool , ty_act , ty_asym1 , ty_asym2 , Cmm_memory_order )                                 :: :: Store {{ com the boolean indicates whether the store is locking }}
    | load ( ty_act , ty_asym , Cmm_memory_order )                                                        :: :: Load
    | rmw ( ty_act ,  ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )            :: :: RMW
    | fence ( Cmm_memory_order )                                                                          :: :: Fence
    | cmp_exch_strong ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: CompareExchangeStrong
    | cmp_exch_weak ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )   :: :: CompareExchangeWeak
    | linux_fence ( Linux_linux_memory_order )                                                            :: :: LinuxFence
    | linux_load ( ty_act , ty_asym , Linux_linux_memory_order )                                          :: :: LinuxLoad
    | linux_store ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                             :: :: LinuxStore
    | linux_rmw ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                               :: :: LinuxRMW
  

  mu_action {{ tex action }} :: 'M_' ::= {{ auxparam 'TY }}
    | ty_loc mu_action_aux :: :: Action
  

grammar

  mu_memop {{ tex memop }} :: 'M_' ::=  {{ auxparam 'TY }} {{ com operations involving the memory state}}
    | ty_asym1 == ty_asym2                            :: :: PtrEq            {{ com pointer equality comparison}}
    | ty_asym1 <> ty_asym2                            :: :: PtrNe            {{ com pointer inequality comparison}}
    | ty_asym1 < ty_asym2                             :: :: PtrLt            {{ com pointer less-than comparison }}
    | ty_asym1 > ty_asym2                             :: :: PtrGt            {{ com pointer greater-than comparison }}
    | ty_asym1 =< ty_asym2                            :: :: PtrLe            {{ com pointer less-than comparison }}
    | ty_asym1 >= ty_asym2                            :: :: PtrGe            {{ com pointer greater-than comparison }}
    | ty_asym1 - ty_act - ty_asym2                    :: :: Ptrdiff          {{ order [[ty_act]] [[ty_asym1]] [[ty_asym2]] }} {{ com pointer subtraction }}
                                                                             {{ tex [[ty_asym1]] -_{ [[ty_act]] } [[ty_asym2]] }}
    | intFromPtr ( ty_act1 , ty_act2 , ty_asym )      :: :: IntFromPtr       {{ com cast of pointer value to integer value }} 
    | ptrFromInt ( ty_act1 , ty_act2 , ty_asym )      :: :: PtrFromInt       {{ com cast of integer value to pointer value }} 
    | ptrValidForDeref ( ty_act , ty_asym )           :: :: PtrValidForDeref {{ com dereferencing validity predicate }}
    | ptrWellAligned ( ty_act , ty_asym )             :: :: PtrWellAligned
    | ptrArrayShift ( ty_asym1 ,  ty_act , ty_asym2 ) :: :: PtrArrayShift
    | memcpy ( ty_asym1 , ty_asym2 , ty_asym3 )       :: :: Memcpy
    | memcmp ( ty_asym1 , ty_asym2 , ty_asym3 )       :: :: Memcmp
    | realloc ( ty_asym1 , ty_asym2 , ty_asym3 )      :: :: Realloc          {{ com TODO: not sure about this }}
    | va_start ( ty_asym1 , ty_asym2 )                :: :: Va_start
    | va_copy ( ty_asym )                             :: :: Va_copy
    | va_arg ( ty_asym , ty_act )                     :: :: Va_arg
    | va_end ( ty_asym )                              :: :: Va_end
  
grammar

  mu_paction {{ tex paction }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions with polarity }}
    |  mu_action          :: M :: Positive {{ com positive, sequenced by both \ottkw{let\ weak} and \ottkw{let\ strong} }} {{ ocaml Paction ( Pos ,  [[mu_action]] ) }}
    |  neg ( mu_action )  :: M :: Negative {{ com negative, only sequenced by \ottkw{let\ strong} }} {{ ocaml Paction ( Neg , [[mu_action]] ) }}


grammar

  mu_expr_aux {{ tex expr\_aux }} :: 'M_E' ::= {{ auxparam 'TY }} {{ com (effectful) expressions }}
    | pure ( mu_pexpr )                                                                             :: :: pure
    | memop ( mu_memop )                                                                            :: :: memop {{ com pointer op involving memory }}
    | mu_paction                                                                                    :: :: action {{ com memory action }}
    | skip                                                                                          :: :: skip
    | ccall ( ty_act , ty_asym , </ ty_asymi // , // i /> )                                         :: :: ccall {{ com C function call }}
    | pcall ( mu_name , </ ty_asymi // , // i /> )                                                  :: :: proc {{ com Core procedure call }}


   mu_expr {{ tex expr }} :: 'M_E' ::= {{ auxparam 'TY }} {{ com (effectful) expressions with location and annotations }}
     | ty_loc annots mu_expr_aux :: :: Expr


grammar

   mu_texpr_aux {{ tex texpr\_aux }} :: 'M_E' ::= {{ auxparam 'TY }} {{ com top-level expressions }}
    | let mu_sym_or_pattern = mu_pexpr in mu_texpr                :: :: let % TODO: bindings
    | let weak mu_pattern = mu_expr in mu_texpr                   :: :: wseq  {{ com weak sequencing }} % TODO: bindings
    | let strong mu_sym_or_pattern = mu_expr in mu_texpr          :: :: sseq  {{ com strong sequencing }} % TODO: bindings
    | case ty_asym with </ | mu_patterni => mu_texpri // i /> end :: :: case  {{ com pattern matching }} % TODO: bindings
    | if ty_asym then mu_texpr1 else mu_texpr2                    :: :: if
    | bound [ ty_int ] ( mu_texpr )                             :: :: bound {{ com $\ldots$and boundary }} %(* this ctor doesn't exist at runtine *)
    | unseq ( mu_expr1 , .. , mu_exprn )                          :: :: unseq {{ com unsequenced expressions }}
    | nd ( mu_texpr1 , .. , mu_texprn )                           :: :: nd    {{ com nondeterministic sequencing }}
    | done ty_asym                                                :: :: done
    | undef ty_loc UB_name                                      :: :: undef
    | run Symbol_sym ty_asym1 , .. , ty_asymn                     :: :: run  {{ com run from label }}


   mu_texpr {{ tex texpr }} :: 'M_T' ::= {{ auxparam 'TY }} {{ com top-level expressions with location and annotations }}
     | ty_loc annots mu_texpr_aux :: :: Expr


% substitutions
% % single pexpr_ code_sym :: subst
% % multiple pexpr_ code_sym :: msubst

grammar

  terminals :: 'terminals_' ::=
    | \      :: :: lambda    {{ tex \lambda         }}
    | -->    :: :: red       {{ tex \longrightarrow }}
    |  ->    :: :: arrow     {{ tex \rightarrow     }}
    |  =>    :: :: synths    {{ tex \Rightarrow     }}
    |  <=    :: :: checks    {{ tex \Leftarrow      }}
    | |-     :: :: turnstile {{ tex \vdash          }}
    | inEnv  :: :: inEnv     {{ tex \in             }}
    | pi     :: :: pi        {{ tex \Pi             }}
    | forall :: :: forall    {{ tex \forall         }}
    | --o    :: :: lollipop  {{ tex \multimap       }}
    | -)     :: :: implies   {{ tex \supset         }}
    | sigma  :: :: sigma     {{ tex \Sigma          }}
    | exists :: :: exists    {{ tex \exists         }}
    | *      :: :: star      {{ tex \star           }}
    | /\     :: :: and       {{ tex \wedge          }}
    | /\\    :: :: big_and   {{ tex \bigwedge       }}
    | neg    :: :: neg       {{ tex \neg            }}
    | =      :: :: eq        {{ tex =               }}
    | <>     :: :: neq       {{ tex \neq            }}
    | =<     :: :: lte       {{ tex \leq            }}
    | >=     :: :: gte       {{ tex \geq            }}
    | &      :: :: ampersand {{ tex \&              }}


grammar

  z, Z_t :: 'Z_' ::= {{ ocaml Z.t }} {{ phantom }} {{ com OCaml arbitrary-width integer }}
    | of_mem_int ty_mem_int :: M :: of_MemInt {{ ocaml Memory.integer_value_to_num }}
                                              {{ tex \mathrm{of\_mem\_int}( [[ty_mem_int]] ) }}
    | of_nat ty_nat         :: M :: of_Nat    {{ ocaml                             }}
                                              {{ tex \mathrm{of\_nat}( [[ty_nat]] ) }}

grammar

  lit :: 'Lit_' ::=
    | tyvar_sym  :: :: Sym
    | ( )        :: :: Unit
    | ty_bool  :: :: Bool
    | int Z_t :: :: Z
    | ptr Z_t :: :: Pointer


grammar

  bool_op :: '' ::=      {{ auxparam 'bt }}
    | neg index_term                         :: :: Not
    | index_term1 = index_term2              :: :: Eq
    | /\\ ( index_term1 , .. , index_termn ) :: :: And


  list_op :: '' ::= {{ auxparam 'bt }}
    | [ index_term1 , .. , index_termn ] :: :: List
    | index_term ^ ty_int              :: :: NthList {{ order [[ty_int]] [[index_term]] }}
                                                     {{ tex [[index_term]]^{([[ty_int]])} }}

  tuple_op :: '' ::= {{ auxparam 'bt }}
    | ( index_term1 , .. , index_termn ) :: :: Tuple
    | index_term ^ ty_int              :: :: NthTuple {{ tex [[index_term]]^{([[ty_int]])} }}


  pointer_op :: '' ::= {{ auxparam 'bt }}
    | nullop :: :: Null


  array_op :: '' ::= {{ auxparam 'bt }}
    | index_term1 [ int Z_t ]     :: :: ArrayGet


  param_op :: '' ::= {{ auxparam 'bt }}
    | index_term ( index_term1 , .. , index_termn ) :: :: App


  struct_op :: '' ::= {{ auxparam 'bt }}
    | ty_tag index_term . Symbol_identifier :: :: StructMember {{ tex [[index_term]] . [[Symbol_identifier]] }}


  index_term_aux :: '' ::= {{ auxparam 'bt }}
    | bool_op    :: :: Bool_op
    | list_op    :: :: List_op
    | pointer_op :: :: Pointer_op
    | array_op   :: :: Array_op
    | param_op   :: :: Param_op


  ty_bt :: '' ::= {{ tex bt }} {{ ocaml 'bt }} {{ phantom }} {{ com OCaml type variable for base types }}
    | _bt :: X :: BT {{ tex }} {{ com Ott-hack, ignore }}


  index_term :: '' ::= {{ auxparam 'bt }}
    | lit                                                                     ::   :: Lit
    | index_term_aux ty_bt                                                    ::   :: IT
    | ( index_term )                                                          :: S :: Paren {{ ocaml [[index_term]] }} {{ com parentheses }}
    | index_term [ index_term1 / tyvar_sym1 , .. , index_termn / tyvar_symn ] :: M :: Subs  {{ ocaml INDEX_TERM_SUB }}


grammar

  arg :: ArgTy_ ::= {{ com argument types }}
    | pi tyvar_sym : base_type . arg   :: :: Computational
    | forall tyvar_sym : logSort . arg :: :: Logical
    | resource --o arg                 :: :: Resource
    | index_term -) arg                :: :: Constraint
    | I                                :: :: I


  ret :: RetTy_ ::= {{ com return types }}
    | sigma tyvar_sym : base_type . ret :: :: Computational
    | exists tyvar_sym : logSort . ret  :: :: Logical
    | resource * ret                    :: :: Resource
    | index_term /\ ret                 :: :: Constraint
    | I                                 :: :: I


grammar

  C {{ tex \Gamma }} :: Comp_ ::= {{ com computational var env }}
    | empty                  :: :: empty
    | C , x : base_type :: :: cons


grammar

  L {{ tex \Lambda }} :: Log_ ::= {{ com logical var env }}
    | empty :: :: empty
    | L , x :: :: cons


grammar

  N {{ tex \Xi }} :: Con_ ::= {{ com constraints env }}
    | empty    :: :: empty
    | N , phi  :: :: cons


grammar

  formula :: 'formula_' ::=          
    | judgement                  :: :: judgement
    | not ( formula )            :: ::  not  
    | tyvar_sym : base_type inEnv C :: :: xInC
    | Symbol_sym : struct ty_tag & </ Symbol_identifieri : T_cti // , // i /> inEnv C :: :: structInC
    % HELP | </ C ; L ; N |- ty_mem_valuei => y , base_typei , index_termi  // i /> :: :: indexed_infer_mu_value
    | formula1 .. formulan       :: :: dots

defns
  Jtype :: '' ::= 


defn
    C ; L ; N |- mu_value => tyvar_sym , base_type , index_term :: :: Val :: Val_ by


    ---------------------------------------------------------------- :: Obj_Int
    C ; L ; N |- ty_mem_int => y , integer , y = int of_mem_int ty_mem_int _bt


    --------------------------------------------------- :: Obj_Ptr_Null
    C ; L ; N |- nullptr => y , loc , y = nullop _bt _bt


    ------------------------------------------------------------ :: Obj_Ptr_Func
    C ; L ; N |- funcptr tyvar_sym => y , loc , y = tyvar_sym _bt


    --------------------------------------------------------------------- :: Obj_Ptr_Conc
    C ; L ; N |- concptr ty_nat => y , loc , y = ptr of_nat ty_nat _bt


    C ; L ; N |- mu_loaded_value1 => y1 , base_type , index_term1 .. C ; L ; N |- mu_loaded_valuen => yn , base_type , index_termn
    ---------------------------------------------------------------------------------------------------------------------------- :: Obj_Arr
    C ; L ; N |- array ( mu_loaded_value1 , .. , mu_loaded_valuen ) => y , array base_type , /\\ ( index_term1 , .. , index_termn ) _bt [ y [ int z1 ] _bt / y1 , .. , y [ int zn ] _bt / yn ]


    % HELP Symbol_sym : struct ty_tag & </ Symbol_identifieri : T_cti // , // i /> inEnv C :: :: structInC
    % HELP </ C ; L ; N |- ty_mem_valuei => y , base_typei , index_termi  // i />
    % HELP ---------------------------------------------------------------------------------------------------------------------------- :: Obj_Struct
    % HELP C ; L ; N |- ( struct ty_tag ) { </ . Symbol_identifieri : T_cti = ty_mem_valuei // , // i /> } => y , struct ty_tag ,  /\\ ( index_term1 , .. , index_termn ) _bt [ ty_tag y . Symbol_identifier1 _bt / y1 , .. , ty_tag y . Symbol_identifiern _bt / yn ]
    
    % Ask: Typing structs and unions, floats (unsupported?)
    % ANS: like arrays/lists, but with names


    ------------------------------------------- :: Unit
    C ; L ; N |- Unit => y , unit , y = ( ) _bt


    ------------------------------------------- :: True
    C ; L ; N |- True => y , bool , y = true _bt


    --------------------------------------------- :: False
    C ; L ; N |- False => y , bool , y = false _bt


    C ; L ; N |- mu_value1 =>  y1 , base_type , index_term1 .. C ; L ; N |- mu_valuen => yn , base_type , index_termn
    ----------------------------------------------------------------------------------------------------------------- :: List
    C ; L ; N |- base_type [ mu_value1 , .. , mu_valuen ] => y , [ base_type ] , ( /\\ ( index_term1 , .. , index_termn ) _bt ) [ y ^ ty_int1 _bt / y1 , .. , y ^ ty_intn _bt / yn ]


    C ; L ; N |- mu_value1 =>  y1 , base_type1 , index_term1 .. C ; L ; N |- mu_valuen => yn , base_typen , index_termn
    ------------------------------------------------------------------------------------------------------------------- :: Tuple
    C ; L ; N |- ( mu_value1 , .. , mu_valuen ) => y , ( base_type1 , .. , base_typen ) , /\\ ( index_term1 , .. , index_termn ) _bt [ y ^ ty_int1 _bt / y1 , .. , y ^ ty_intn _bt / yn ]

defn
    C ; L ; N |- mu_pexpr_aux => ret :: :: PExpr :: PExpr_ by


    x : base_type inEnv C
    ------------------------------------------ :: Var
    C ; L ; N |- x => sigma y  : base_type . I


    % DEFER: globals (needs resources)


    C ; L ; N |- mu_value => y , base_type , index_term
    ------------------------------------------------------------- :: Val
    C ; L ; N |- mu_value => sigma y : base_type . index_term /\ I


    % NOT IMPLEMENTED: constrained, undefined
    % ANS: undef, error - check if context inconsistent
    % ASK: error, ctor, array_shift, member_shift
    % ANS: not spine, see as simple function applications

    x : bool inEnv C
    ------------------------------------------------------------------ :: Not
    C ; L ; N |- not ( x ) => sigma y : bool . y = ( neg x _bt ) _bt /\ I


    % TODO: op

    % NOT IMPLEMENTED: struct, union, memberof

    % ASK: call

    % TODO: assert_under, bool_to_integer, conv_int

    % ASK: wrapI

    % ASK: if, case, let (pattern-matching)
    % ANS: usual for if, case

    % TODO: let, done
    % NOTE: intro fresh computational variables for binding constructs, to have logical constraints be consistent
    %       e.g. let x = 5 in let x = 3 in ...
    % 5 : sigma y . y = 5
    % x' = 5
    % 
    %                ^ G = { x = 5 }
    %                             ^ G { x = 5, x = 3 }
    % TODO: expression : turns into => , statement : turns into <=

