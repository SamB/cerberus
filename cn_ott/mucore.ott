% The grammars in this file are A-normalised
% Specificying syntactic values is thus not a straightforward sub-rule
% And so they are marked by productions with a ( :: V :: )
% Identifiers in such productions should be understood as values

embed {{ tex-preamble
\geometry{landscape}
\renewcommand{\[[TEX_NAME_PREFIX]]kw}[1]{ \texttt{#1} }
\renewcommand{\[[TEX_NAME_PREFIX]]drule}[4][]{ {\displaystyle\frac{\begin{array}{l}#2\end{array} }{#3}\quad\[[TEX_NAME_PREFIX]]drulename{#4} }\\[\baselineskip] }
}}

metavar ident , x , y , yp {{ tex y_p }} , v , vp {{ tex v_p }} , _ ::= {{ phantom }}
  {{ com v is for values, subscript p is for pointers, rest are identifiers }}

grammar

  Sctypes_t , ct {{ tex \tau }} :: '' ::= {{ ocaml Sctypes.t }} {{ phantom }} {{ com C type }}
    | ct ast :: :: Pointer {{ com pointer to type $[[ct]]$ }} {{ tex [[ct]] { [[ast]] } }}


grammar

  ty_tag {{ tex tag }} :: 'Ty_tag' ::= {{ ocaml tag }} {{ phantom }} {{ com OCaml type for struct/union tag }}
    | ident :: :: ident

  base_type {{ tex \beta }} :: '' ::= {{ com base types }}
    | unit                                      ::   :: Unit    {{ com unit              }}
    | bool                                      ::   :: Bool    {{ com boolean           }}
    | integer                                   ::   :: Integer {{ com integer           }}
    | real                                      ::   :: Read    {{ com rational numbers? }}
    | loc                                       ::   :: Loc     {{ com location          }}
    | array base_type                           ::   :: Array   {{ com array             }}
    | [ base_type ]                             ::   :: ListTy  {{ com list              }}
    | ( base_type1 , .. , base_typen )          ::   :: TupleTy {{ com tuple             }}
    | struct ty_tag                             ::   :: Struct  {{ com struct            }}
    | { base_type }                             ::   :: Set     {{ com set               }}
    | opt ( base_type )                         ::   :: Option  {{ com option            }}
    | base_type1 , .. , base_typen -> base_type ::   :: Param   {{ com parameter types   }}
    | of_ctype ( ct )                           :: M :: Of_Ctype {{ com of a C type      }}
                                                                 {{ tex \mathrm{of\_ctype}( [[ct]] ) }} 
                                                                 {{ ocaml (BT.of_sct ( [[ct]] ) ) }}

grammar

  % Binary operators
  binop :: 'Op' ::= {{ ocaml Core.binop }} {{ phantom }} {{ com binary operators }}
    % arithmetic operators (integer -> integer -> integer)
    | +     :: :: Add   {{ tex \texttt{+}         }} {{ com addition       }}
    | -     :: :: Sub   {{ tex \texttt{-}         }} {{ com subtraction    }}
    | *     :: :: Mul   {{ tex \texttt{*}         }} {{ com multiplication }}
    | /     :: :: Div   {{ tex \texttt{/}         }} {{ com division       }}
    | rem_t :: :: Rem_t                              {{ com modulus        }}
    | rem_f :: :: Rem_f                              {{ com remainder      }}
    | ^     :: :: Exp   {{ tex \texttt{\char`^}   }} {{ com exponentiation }}
    % relational operators ( integer -> integer -> bool)
    | =     :: :: Eq    {{ tex \texttt{=}         }} {{ com equality, defined both for integer and C types }}
    | >     :: :: Gt    {{ tex \texttt{>}         }} {{ com greater than                                   }}
    | <     :: :: Lt    {{ tex \texttt{<}         }} {{ com less than                                      }}
    | >=    :: :: Ge    {{ tex \texttt{>=}        }} {{ com greater than or equal to                       }}
    | <=    :: :: Le    {{ tex \texttt{<=}        }} {{ com less than or equal to                          }}
    % logical connectives ( bool -> bool -> bool)
    | /\    :: :: And   {{ tex \texttt{/\char`\\} }} {{ com conjucntion }}
    | \/    :: :: Or    {{ tex \texttt{\char`\\/} }} {{ com disjunction }}


grammar

  polarity :: '' ::= {{ ocaml Core.polarity }} {{ phantom }} {{ com memory action polarities }}
    | Pos :: :: Pos {{ com sequenced by \ottkw{let\ weak} and \ottkw{let\ strong} }}
    | Neg :: :: Neg {{ com only sequenced by \ottkw{let\ strong} }}


metavar impl_const ::= {{ ocaml Implementation.implementation_constant }} {{ phantom }}
  {{ com implementation-defined constant }}

grammar

  tyvar_sym {{ tex ident }}:: 'Tyvar_sym_' ::= {{ ocaml 'sym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ident :: :: ident

  Symbol_sym {{ tex ident }}:: '' ::= {{ ocaml Symbol.sym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ident  :: :: ident
    | ty_tag :: :: ty_tag {{ com hack for struct typing rules }}

grammar

  mu_name {{ tex name }} :: '' ::= {{ ocaml Symbol.sym Core.generic_name }} {{ phantom }}
    | Symbol_sym :: :: Sym  {{ com Core identifier                 }}
    | impl_const :: :: Impl {{ com implementation-defined constant }}

metavar ty_mem_int {{ tex mem\_int }} ::= {{ ocaml Impl_mem.integer_value }} {{ phantom }}
  {{ com memory integer value }}

metavar Symbol_identifier {{ tex member }} ::= {{ ocaml Symbol.identifier }} {{ phantom }}
  {{ com C struct/union member name }}

metavar annots ::= {{ ocaml annot list }} {{ phantom }}
  {{ com annotations }}

metavar ty_nat {{ tex nat }} ::= {{ ocaml Nat_big_num.num }} {{ phantom }}
  {{ com OCaml arbitrary-width natural number }}

indexvar n, i ::= {{ phantom }} {{ com index variables }}

grammar

  ty_mem_ptr {{ tex mem\_ptr }} :: 'PV' ::= {{ ocaml Impl_mem.pointer_value }} {{ phantom }} {{ com pointer values }}
    | nullptr            :: :: null       {{ com null pointer }}
    | funcptr Symbol_sym :: :: function   {{ com function pointer }}
    | concptr ty_nat     :: :: concrete   {{ com concrete pointer }}

grammar

  ty_mem_value {{ tex mem\_val }} :: 'MV' ::= {{ phantom }} {{ ocaml Impl_mem.mem_value }} {{ com memory value }}
    | int ty_mem_int                                                                 :: :: integer
    | ty_mem_ptr                                                                     :: :: pointer
    | array ( </ ty_mem_valuei // i /> )                                             :: :: array
    | ( struct Symbol_sym ) { </ . Symbol_identifieri = ty_mem_valuei // , // i /> } :: :: struct
    | union Symbol_sym Symbol_identifier                                             :: :: union


grammar

  T_ct {{ tex \tau }} :: 'T_ct_of_' ::= {{ ocaml T.ct }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ct :: :: ct


grammar

  mu_object_value {{ tex object\_value }} :: 'M_OV' ::=  {{ auxparam 'TY }} {{ com C object values (inhabitants of object types), which can be read/stored }}
    | ty_mem_int                                                                                :: :: integer {{ com integer value  }}
    | ty_mem_ptr                                                                                :: :: pointer {{ com pointer value  }}
    | array ( </ mu_loaded_valuei // , // i /> )                                                :: :: array   {{ com C array value  }}
    | ( struct Symbol_sym ) { </ . Symbol_identifieri : T_cti = ty_mem_valuei // , // i /> }    :: :: struct  {{ com C struct value }}
    | ( union Symbol_sym ) { . Symbol_identifier = ty_mem_value }                               :: :: union   {{ com C union value  }}


  mu_loaded_value {{ tex loaded\_value }} :: 'M_LV' ::= {{ auxparam 'TY }} {{ com potentially unspecified C object values }}
    | specified mu_object_value :: :: specified {{ com specified loaded value }}


grammar

  T_bt {{ tex \beta }} :: 'T_bt_' ::= {{ ocaml T.bt }} {{ phantom }} {{ com Ott-hack, ignore }}
    | base_type :: :: BaseType


grammar

  mu_value {{ tex value }} :: 'M_V' ::= {{ auxparam 'TY }} {{ com Core values }}
    | mu_object_value                     :: :: object {{ com C object value        }}
    | mu_loaded_value                     :: :: loaded {{ com loaded C object value }}
    | Unit                                :: :: unit   {{ com unit                  }}
    | True                                :: :: true   {{ com boolean true          }}
    | False                               :: :: false  {{ com boolean false         }}
    | T_bt [ mu_value1 , .. , mu_valuei ] :: :: list   {{ com list                  }}
    | ( mu_value1 , .. , mu_valuei )      :: :: tuple  {{ com tuple                 }}

grammar

  mu_ctor {{ tex ctor }} :: 'M_C' ::= {{ com data constructors }}
    | Nil T_bt    :: :: nil         {{ com empty list                     }} % : [bTy]
    | Cons        :: :: cons        {{ com list cons                      }} % : bTy -> [bTy] -> [bTy]
    | Tuple       :: :: tuple       {{ com tuple                          }} % : bTy1 -> ... -> bTyN -> (bTy1, ..., bTyN)
    | Array       :: :: array       {{ com C array                        }} % : bTy -> ... -> bTy -> array bTy
    | Ivmax       :: :: ivmax       {{ com max integer value              }} % : ctype -> integer
    | Ivmin       :: :: ivmin       {{ com min integer value              }} % : ctype -> integer
    | Ivsizeof    :: :: ivsizeof    {{ com sizeof value                   }} % : ctype -> integer
    | Ivalignof   :: :: ivalignof   {{ com alignof value                  }} % : ctype -> integer
    | IvCOMPL     :: :: ivCOMPL     {{ com bitwise complement             }} % : ctype -> integer -> integer
    | IvAND       :: :: ivAND       {{ com bitwise AND                    }} % : ctype -> integer -> integer -> integer
    | IvOR        :: :: ivOR        {{ com bitwise OR                     }} % : ctype -> integer -> integer -> integer
    | IvXOR       :: :: ivXOR       {{ com bitwise XOR                    }} % : ctype -> integer -> integer -> integer
    | Specified   :: :: specified   {{ com non-unspecified loaded value   }} % : objTy -> loaded objTy
    | Fvfromint   :: :: fvfromint   {{ com cast integer to floating value }} % : integer -> floating
    | Ivfromfloat :: :: ivfromfloat {{ com cast floating to integer value }} % : ctype -> floating -> integer

metavar ty_loc {{ tex loc }} ::= {{ ocaml Location_ocaml.t }} {{ phantom }}
  {{ com OCaml type for C source }}

grammar

  ty_sym_opt_T_bt {{ tex ident\_opt\_\beta }} :: '' ::= {{ ocaml ( Symbol.sym option * T.bt ) }} {{ phantom }}
                                                        {{ com type annotated optional identifier }}
    | _ : T_bt          :: :: No_sym % (+ binders = {} +)
    | Symbol_sym : T_bt :: :: Just   % (+ binders = Symbol_sym +)


grammar

  mu_pattern_aux {{ tex pattern\_aux }} :: 'M_Case' ::=
    | ty_sym_opt_T_bt                         :: :: Base % (+ binders = binders( maybesym_base_type ) +)
    | mu_ctor ( </ mu_patterni // , // i /> ) :: :: Ctor % (+ binders = binders( </ mu_patterni // , // i /> ) +)


  mu_pattern {{ tex pattern }} :: 'M_' ::=
    | ty_loc annots mu_pattern_aux :: :: Pattern % (+ binders = binders(mu_pattern_aux) +)


grammar

  mu_sym_or_pattern {{ tex ident\_or\_pattern }} :: 'M_' ::= {{ auxparam 'TY }}
    | Symbol_sym :: :: Symbol % (+ binders = Symbol_sym +)
    | mu_pattern :: :: Pat    % (+ binders = binders(mu_pattern_aux) +)


metavar Mem_mem_iv_constraint {{ tex mem\_iv\_c }} ::= {{ ocaml Mem.mem_iv_constraint }} {{ phantom }}
  {{ com OCaml type for memory constraints on integer values }}

metavar UB_name ::= {{ ocaml Undefined.undefined_behaviour }} {{ phantom }}
 {{ com undefined behaviour }}

metavar ty_string {{ tex string }} ::= {{ ocaml string }} {{ phantom }}
  {{ com OCaml string }}

metavar tyvar_TY ::= {{ ocaml 'TY }} {{ phantom }}
  {{ com OCaml type variable for types }}

grammar

  ty_asym {{ tex ident }} :: 'ty_asym_' ::= {{ ocaml 'TY asym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | Symbol_sym :: :: Symbol_sym


grammar

  ty_act {{ tex \tau }} :: 'Ty_act_of' ::= {{ ocaml 'TY act }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ct :: :: ct


grammar

  mu_pexpr_aux {{ tex pexpr\_aux }} :: 'M_PE' ::= {{ auxparam 'TY }} {{ com pure expressions }}
    | Symbol_sym                                                                :: V :: sym
    | impl_const                                                                :: V :: impl         {{ com implementation-defined constant           }}
    | mu_value                                                                  :: V :: val
    | constrained ( </ Mem_mem_iv_constrainti , ty_asymi // , // i /> )         :: V :: constrained  {{ com constrained value                         }}
    | error ( ty_string , ty_asym )                                             :: V :: error        {{ com impl-defined static error                 }}
    | mu_ctor ( </ ty_asymi // , // i /> )                                      ::   :: ctor         {{ com data constructor application              }}
    | array_shift ( ty_asym1 , T_ct , ty_asym2 )                                ::   :: array_shift  {{ com pointer array shift                       }}
    | member_shift ( ty_asym , Symbol_sym , Symbol_identifier )                 ::   :: member_shift {{ com pointer struct/union member shift         }}
    | not ( ty_asym )                                                           ::   :: not          {{ com boolean not                               }}
    | ty_asym1 binop ty_asym2                                                   ::   :: op           {{ order [[binop]] [[ty_asym1]] [[ty_asym2]] }} {{ com binary operations }}
    | ( struct Symbol_sym ) { </ . Symbol_identifieri = ty_asymi // , // i /> } :: V :: struct       {{ com C struct expression                       }}
    | ( union Symbol_sym ) { . Symbol_identifier = ty_asym }                    :: V :: union        {{ com C union expression                        }}
    | memberof  ( Symbol_sym , Symbol_identifier , ty_asym )                    ::   :: memberof     {{ com C struct/union member access              }}
    | mu_name ( ty_asym1 , .. , ty_asymn )                                      ::   :: call         {{ com pure function call                        }}
    
    | assert_undef ( ty_asym , ty_loc , UB_name )                               ::   :: assert_undef
    | bool_to_integer ( ty_asym )                                               ::   :: bool_to_integer
    | conv_int ( ty_act , ty_asym )                                             ::   :: conv_int
    | wrapI ( ty_act , ty_asym )                                                ::   :: wrapI


  mu_pexpr {{ tex pexpr }} :: 'M_P' ::= {{ auxparam 'TY }} {{ com pure expressions with location and annotations }}
    | ty_loc annots tyvar_TY mu_pexpr_aux :: V :: expr


grammar

  mu_tpexpr_aux {{ tex tpexpr\_aux }} :: 'M_PE' ::= {{ auxparam 'TY }} {{ com top-level pure expressions }}
    | undef ty_loc UB_name                                       :: V :: undef {{ com undefined behaviour }}
    | case ty_asym of </ | mu_patterni => mu_tpexpri // i /> end ::   :: case  {{ com pattern matching    }} % TODO: binding
    | let mu_sym_or_pattern = mu_pexpr in mu_tpexpr              ::   :: let   {{ com pure let            }} % TODO: binding
    | if ty_asym then mu_tpexpr1 else mu_tpexpr2                 ::   :: if    {{ com pure if             }}
    | done ty_asym                                               :: V :: done  {{ com pure done           }}

  mu_tpexpr {{ tex tpexpr }} :: 'M_TP' ::= {{ auxparam 'TY }} {{ com pure top-level pure expressions with location and annotations }}
    | ty_loc annots tyvar_TY mu_tpexpr_aux :: V :: expr
    | [ C / C' ] mu_tpexpr                 :: M :: contextSub {{ ocaml MU_TPEXPR_CONTEXT_SUB }}


grammar

  m_kill_kind :: 'M_' ::=
    | dynamic     :: :: Dynamic
    | static T_ct :: :: Static


grammar

  ty_bool {{ tex bool }} , _b {{ tex \_ }} :: '' ::=   {{ ocaml bool  }} {{ phantom }} {{ com OCaml booleans }}
    | true  :: :: True  {{ ocaml true  }}
    | false :: :: False {{ ocaml false }}


metavar Symbol_prefix {{ tex }} ::= {{ ocaml Symbol.prefix }} {{ phantom }}
  {{ com OCaml type for symbol prefix }}

metavar Cmm_memory_order {{ tex mem\_order }} , _mem_order {{ tex \_ }} ::= {{ ocaml Cmm_csem.memory_order }} {{ phantom }}
  {{ com OCaml type for memory order }}

metavar Linux_linux_memory_order {{ tex linux\_mem\_order }} ::= {{ ocaml Linux.linux_memory_order }} {{ phantom }}
  {{ com OCaml type for Linux memory order }}

metavar ty_int {{ tex k }} ::= {{ ocaml int }} {{ phantom }}
  {{ com OCaml fixed-width integer }}

grammar

  mu_action_aux {{ tex action\_aux }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions }}
    | create ( ty_asym , ty_act ) Symbol_prefix                                                           :: :: Create
    | create_readonly ( ty_asym1 , ty_act , ty_asym2 ) Symbol_prefix                                      :: :: CreateReadOnly
    | alloc ( ty_asym1 , ty_asym2 ) Symbol_prefix                                                         :: :: Alloc
    | kill ( m_kill_kind , ty_asym )                                                                      :: :: Kill
    | store ( ty_bool , ty_act , ty_asym1 , ty_asym2 , Cmm_memory_order )                                 :: :: Store {{ com true means store is locking }}
    | load ( ty_act , ty_asym , Cmm_memory_order )                                                        :: :: Load
    | rmw ( ty_act ,  ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )            :: :: RMW
    | fence ( Cmm_memory_order )                                                                          :: :: Fence
    | cmp_exch_strong ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: CompareExchangeStrong
    | cmp_exch_weak ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )   :: :: CompareExchangeWeak
    | linux_fence ( Linux_linux_memory_order )                                                            :: :: LinuxFence
    | linux_load ( ty_act , ty_asym , Linux_linux_memory_order )                                          :: :: LinuxLoad
    | linux_store ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                             :: :: LinuxStore
    | linux_rmw ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                               :: :: LinuxRMW


  mu_action {{ tex action }} :: 'M_' ::= {{ auxparam 'TY }}
    | ty_loc mu_action_aux :: :: Action


grammar

  mu_memop {{ tex memop }} :: 'M_' ::=  {{ auxparam 'TY }} {{ com operations involving the memory state}}
    | ty_asym1 == ty_asym2                            :: :: PtrEq            {{ com pointer equality comparison }}
    | ty_asym1 <> ty_asym2                            :: :: PtrNe            {{ com pointer inequality comparison }}
    | ty_asym1 < ty_asym2                             :: :: PtrLt            {{ com pointer less-than comparison }}
    | ty_asym1 > ty_asym2                             :: :: PtrGt            {{ com pointer greater-than comparison }}
    | ty_asym1 =< ty_asym2                            :: :: PtrLe            {{ com pointer less-than comparison }}
    | ty_asym1 >= ty_asym2                            :: :: PtrGe            {{ com pointer greater-than comparison }}
    | ty_asym1 - ty_act - ty_asym2                    :: :: Ptrdiff          {{ order [[ty_act]] [[ty_asym1]] [[ty_asym2]] }} {{ com pointer subtraction }}
                                                                             {{ tex [[ty_asym1]] -_{ [[ty_act]] } [[ty_asym2]] }}
    | intFromPtr ( ty_act1 , ty_act2 , ty_asym )      :: :: IntFromPtr       {{ com cast of pointer value to integer value }}
    | ptrFromInt ( ty_act1 , ty_act2 , ty_asym )      :: :: PtrFromInt       {{ com cast of integer value to pointer value }}
    | ptrValidForDeref ( ty_act , ty_asym )           :: :: PtrValidForDeref {{ com dereferencing validity predicate }}
    | ptrWellAligned ( ty_act , ty_asym )             :: :: PtrWellAligned
    | ptrArrayShift ( ty_asym1 ,  ty_act , ty_asym2 ) :: :: PtrArrayShift
    | memcpy ( ty_asym1 , ty_asym2 , ty_asym3 )       :: :: Memcpy
    | memcmp ( ty_asym1 , ty_asym2 , ty_asym3 )       :: :: Memcmp
    | realloc ( ty_asym1 , ty_asym2 , ty_asym3 )      :: :: Realloc
    | va_start ( ty_asym1 , ty_asym2 )                :: :: Va_start
    | va_copy ( ty_asym )                             :: :: Va_copy
    | va_arg ( ty_asym , ty_act )                     :: :: Va_arg
    | va_end ( ty_asym )                              :: :: Va_end

grammar

  mu_paction {{ tex paction }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions with polarity }}
    |  mu_action          :: M :: Positive {{ com positive, sequenced by both \ottkw{let\ weak} and \ottkw{let\ strong} }} {{ ocaml Paction ( Pos ,  [[mu_action]] ) }}
    |  neg ( mu_action )  :: M :: Negative {{ com negative, only sequenced by \ottkw{let\ strong} }} {{ ocaml Paction ( Neg , [[mu_action]] ) }}


grammar

  mu_expr_aux {{ tex expr\_aux }} :: 'M_E' ::= {{ auxparam 'TY }} {{ com (effectful) expressions }}
    | pure ( mu_pexpr )                                     :: V :: pure   {{ com pure expression             }}
    | memop ( mu_memop )                                    ::   :: memop  {{ com pointer op involving memory }}
    | mu_paction                                            ::   :: action {{ com memory action               }}
    | skip                                                  :: V :: skip   {{ com skip                        }}
    | ccall ( ty_act , ty_asym , </ ty_asymi // , // i /> ) ::   :: ccall  {{ com C function call             }}
    | pcall ( mu_name , </ ty_asymi // , // i /> )          ::   :: proc   {{ com procedure call              }}


   mu_expr {{ tex expr }} :: 'M_E' ::= {{ auxparam 'TY }} {{ com (effectful) expressions with location and annotations }}
     | ty_loc annots mu_expr_aux :: V :: Expr


grammar

   mu_texpr_aux {{ tex texpr\_aux }} :: 'M_E' ::= {{ auxparam 'TY }} {{ com top-level expressions }}
    | let mu_sym_or_pattern = mu_pexpr in mu_texpr                ::   :: let                                          % TODO: bindings
    | let weak mu_pattern = mu_expr in mu_texpr                   ::   :: wseq  {{ com weak sequencing               }} % TODO: bindings
    | let strong mu_sym_or_pattern = mu_expr in mu_texpr          ::   :: sseq  {{ com strong sequencing             }} % TODO: bindings
    | case ty_asym with </ | mu_patterni => mu_texpri // i /> end ::   :: case  {{ com pattern matching              }} % TODO: bindings
    | if ty_asym then mu_texpr1 else mu_texpr2                    ::   :: if    {{ com conditional                   }}
    | bound [ ty_int ] ( mu_texpr )                               :: X :: bound {{ com boundary of a elab of an outermost (ISO: `full') C expr, absent at runtime }}
    | unseq ( mu_expr1 , .. , mu_exprn )                          :: V :: unseq {{ com unsequenced expressions       }}
    | nd ( mu_texpr1 , .. , mu_texprn )                           ::   :: nd    {{ com nondeterministic sequencing   }}
    | done ty_asym                                                :: V :: done  {{ com end of top-level expression   }}
    | undef ty_loc UB_name                                        :: V :: undef {{ com undefined behaviour           }}
    | run Symbol_sym ty_asym1 , .. , ty_asymn                     ::   :: run   {{ com run from label                }}


   mu_texpr {{ tex texpr }} :: 'M_T' ::= {{ auxparam 'TY }} {{ com top-level expressions with location and annotations }}
     | ty_loc annots mu_texpr_aux :: V :: Expr


% substitutions
% % single pexpr_ code_sym :: subst
% % multiple pexpr_ code_sym :: msubst

grammar

  terminals :: 'terminals_' ::=
    | \      :: :: lambda    {{ tex \lambda                          }}
    | -->    :: :: red       {{ tex \longrightarrow                  }}
    |  ->    :: :: arrow     {{ tex \rightarrow                      }}
    |  ~>    :: :: leadsto   {{ tex \leadsto                         }}
    |  =>    :: :: synths    {{ tex \Rightarrow                      }}
    |  <=    :: :: checks    {{ tex \Leftarrow                       }}
    | |-     :: :: turnstile {{ tex \vdash                           }}
    | inEnv  :: :: inEnv     {{ tex \in                              }}
    | pi     :: :: pi        {{ tex \Pi                              }}
    | forall :: :: forall    {{ tex \forall                          }}
    | --o    :: :: lollipop  {{ tex \multimap                        }}
    | -)     :: :: implies   {{ tex \supset                          }}
    | sigma  :: :: sigma     {{ tex \Sigma                           }}
    | exists :: :: exists    {{ tex \exists                          }}
    | *s     :: :: star      {{ tex \star                            }}
    | *      :: :: times     {{ tex \times                           }}
    | /\     :: :: and       {{ tex \wedge                           }}
    | /\\    :: :: big_and   {{ tex \bigwedge                        }}
    | neg    :: :: neg       {{ tex \neg                             }}
    | =      :: :: eq        {{ tex =                                }}
    | <>     :: :: neq       {{ tex \neq                             }}
    | =<     :: :: lte       {{ tex \leq                             }}
    | >=     :: :: gte       {{ tex \geq                             }}
    | &      :: :: ampersand {{ tex \ \&                             }}
    | cdot   :: :: cdot      {{ tex \cdot                            }}
    | |      :: :: bar       {{ tex \mid                             }}
    | +ptr   :: :: addptr    {{ tex \mathbin{ {+}_{ \mathrm{ptr} } } }}
    | |->    :: :: mapsto    {{ tex \mapsto                          }}
    | ast    :: :: ast       {{ tex \ast                             }}


grammar

  Z_t {{ tex z }} :: 'Z_' ::= {{ ocaml Z.t }} {{ phantom }} {{ com OCaml arbitrary-width integer }}
    | of_mem_int ty_mem_int :: M :: of_MemInt {{ ocaml Memory.integer_value_to_num            }}
                                              {{ tex \mathrm{of\_mem\_int}( [[ty_mem_int]] )  }}
    | of_nat ty_nat         :: M :: of_Nat    {{ ocaml (* Z.t = Nat_big_num.num *)            }}
                                              {{ tex \mathrm{of\_nat}( [[ty_nat]] )           }}
    | of_ctype ct           :: M :: of_Ctype  {{ ocaml z_ ( Memory.size_of_ctype ( [[ct]] ) ) }}
                                              {{ tex \mathrm{of\_ctype}( [[ct]] )             }}
                                              {{ com size of a C type                         }}
    | ptr_size              :: M :: Ptr_size  {{ ocaml Memory.size_of_pointer                 }}
                                              {{ com size of a pointer                        }}

grammar

  rationals {{ tex \mathbb{Q} }} :: 'Q_' ::= {{ ocaml ( int * int ) }} {{ phantom }} {{ com OCaml type for rational numbers }}
    | one               :: X :: One {{ ocaml (1, 1) }} {{ tex 1 }}
    | ty_int1 / ty_int2 ::   :: Frac {{ ocaml ( [[ty_int1]], [[ty_int2]] ) }} {{ tex \frac{[[ty_int1]]}{[[ty_int2]]} }}

grammar

  lit :: 'Lit_' ::=
    | tyvar_sym :: :: Sym
    | ( )       :: :: Unit
    | ty_bool   :: :: Bool
    | int Z_t   :: :: Z
    | rationals :: :: Q
    | ptr Z_t   :: :: Pointer


metavar ty_bt {{ tex bt }} , _bt {{ tex }} ::= {{ ocaml 'bt }} {{ phantom }}
  {{ com Ott-hack, ignore }}


grammar

  bool_op :: '' ::= {{ auxparam 'bt }}
    | neg term                         :: :: Not
    | term1 = term2                    :: :: Eq
    | /\\ ( </ termi // , // i />    ) :: :: And


  arith_op :: '' ::= {{ auxparam 'bt }}
    | term1 * term2 :: :: Mul

  list_op :: '' ::= {{ auxparam 'bt }}
    | nil                    :: :: Nil
    | cons term1 term2       :: :: Cons    {{ tex [[term1]] :: [[term2]] }}
    | [ term1 , .. , termn ] :: :: List
    | term ^ ty_int          :: :: NthList {{ order [[ty_int]] [[term]] }}
                                                       {{ tex [[term]]^{([[ty_int]])} }}

  tuple_op :: '' ::= {{ auxparam 'bt }}
    | ( term1 , .. , termn ) :: :: Tuple
    | term ^ ty_int          :: :: NthTuple {{ tex [[term]]^{([[ty_int]])} }}


  pointer_op :: '' ::= {{ auxparam 'bt }}
    | nullop            :: :: Null
    | term1 +ptr term2  :: :: AddPointer


  BT_t :: '' ::= {{ ocaml BT.t }} {{ phantom }} {{ com Ott-hack, ignore }}
    | base_type :: :: Base_type


  option_op :: '' ::= {{ auxparam 'bt }}
    | none BT_t :: :: Nothing
    | some term :: :: Something


  array_op :: '' ::= {{ auxparam 'bt }}
    | term [ int Z_t ]     :: :: ArrayGet


  param_op :: '' ::= {{ auxparam 'bt }}
    | term ( term1 , .. , termn ) :: :: App


  struct_op :: '' ::= {{ auxparam 'bt }}
    | ty_tag term . Symbol_identifier :: :: StructMember {{ tex [[term]] . [[Symbol_identifier]] }}


  ct_pred :: '' ::= {{ auxparam 'bt }}
    | representable ( ct , term ) :: :: Representable
    | alignedI ( term1 , term2 )  :: :: AlignedI


  term_aux :: '' ::= {{ auxparam 'bt }}
    | arith_op   :: :: Arith_op
    | bool_op    :: :: Bool_op
    | tuple_op   :: :: Tuple_op
    | struct_op  :: :: Struct_op
    | pointer_op :: :: Pointer_op
    | list_op    :: :: List_op
    | array_op   :: :: Array_op
    | ct_pred    :: :: CT_pred
    | option_op  :: :: Option_op
    | param_op   :: :: Param_op


  term :: '' ::= {{ auxparam 'bt }}
    | lit                          ::   :: Lit % TODO: move this into term_aux
    | term_aux ty_bt               ::   :: IT
    | ( term )                     :: S :: Paren {{ ocaml [[term]] }} {{ com parentheses }}
    | [  term1 / tyvar_sym ] term2 :: M :: Subs  {{ ocaml INDEX_TERM_SUB }}


grammar

  IT_t :: '' ::= {{ ocaml IT.t }} {{ phantom }} {{ com Ott-hack, ignore }}
    | term :: :: term


  IT_t_list :: '' ::= {{ auxparam 'bt }} {{ ocaml IT.t list }} {{ phantom }} {{ com Ott-hack, ignore }}
    | [ </ IT_ti // , // i /> ] :: :: Term_list
  

  point :: '' ::= {{ ocaml type point = { pointer: IT.t; size: Z.t; content: IT.t; permission: IT.t; } }} {{ phantom }} {{ com points-to predicate }}
    | IT_t1 |-> ( Z_t , IT_t2 ) IT_t3 :: :: Points_to
      {{ tex [[IT_t1]] \mathrel{ {[[|->]]}_{[[Z_t]], [[IT_t2]]} } [[IT_t3]] }}
      {{ ocaml { pointer = [[IT_t1]] ; size = [[Z_t]] ; content = [[IT_t3]] ; permission = [[IT_t2]] } }}


  predicate_name :: '' ::= {{ com names of predicates }}
    | Sctypes_t :: :: Ctype
    | ty_string :: :: Id


  predicate :: '' ::= {{ ocaml type predicate = { name : predicate_name; pointer: IT.t; iargs: IT.t list; oargs: IT.t list; unused: bool; } }} {{ phantom }} {{ com arbitrary predicate }}
    | predicate_name ( ty_bool ) ( IT_t1 , IT_t_list1 |-> IT_t_list2 ) :: :: Predicate_def
      {{ tex [[predicate_name]] ( [[IT_t1]] , [[IT_t_list1]] \mapsto [[IT_t_list2]] ) }}
      {{ ocaml { name = [[predicate_name]] ; pointer = [[IT_t1]] ; iargs = [[IT_t_list1]] ; oargs = [[IT_t_list2]] ; unsued = [[ty_bool]] } }}


  resource :: '' ::=
    | point     :: :: Point
    | predicate :: :: Predicate


grammar

  arg :: ArgTy_ ::= {{ com argument types }}
    | pi tyvar_sym : base_type . arg     :: :: Computational
    | forall tyvar_sym : base_type . arg :: :: Logical
    | resource --o arg                   :: :: Resource
    | term -) arg                        :: :: Constraint
    | I                                  :: :: I


  ret , _r {{ tex \_ }} :: RetTy_ ::= {{ com return types }}
    | sigma tyvar_sym : base_type . ret  :: :: Computational {{ tex [[sigma]]  [[tyvar_sym]] {:} [[base_type]] . \: [[ret]] }}
    | exists tyvar_sym : base_type . ret :: :: Logical       {{ tex [[exists]] [[tyvar_sym]] {:} [[base_type]] . \: [[ret]] }}
    | resource *s ret                    :: :: Resource
    | term /\ ret                        :: :: Constraint
    | I                                  :: :: I


grammar

  C {{ tex \mathcal{C} }} :: Comp_ ::= {{ phantom }} {{ com computational var env }}
    | cdot                  ::   :: empty
    | C , Symbol_sym : BT_t ::   :: cons
    | C , C'                ::   :: concat
    | fresh ( C )           :: M :: fresh {{ tex \mathrm{fresh}( [[C]] ) }}
                                               {{ ocaml FRESH_COMP_CONTEXT    }}
                                               {{ com identical context except with fresh variable names }}


grammar

  L {{ tex \mathcal{L} }} :: Log_ ::= {{ phantom }} {{ com logical var env }}
    | cdot           :: :: empty
    | L , Symbol_sym :: :: cons


grammar

  N {{ tex \Phi }} :: Con_ ::= {{ phantom }} {{ com constraints env }}
    | cdot     :: :: empty
    | N , term :: :: cons
    | N , ret  :: :: consHack {{ com temporary hack }}


grammar

  R {{ tex \mathcal{R} }} :: Res_ ::= {{ phantom }} {{ com resources env }}
    | cdot         :: :: empty
    | R , resource :: :: cons

grammar

  formula :: 'formula_' ::=
    | judgement                                                                        :: :: judgement
    | smt ( N => ret )                                                                 :: :: smt
        {{ com theorem to be proved: $[[ret]]$ only consists of logical constraints }}
    | Symbol_sym : base_type inEnv C                                                   :: :: xInC
    | Symbol_sym : struct ty_tag & </ Symbol_identifieri : T_cti // i /> inEnv Globals :: :: structInGlobals
    | </ Ci ; Li ; Ni |- ty_mem_valuei => mem yi , base_typei , termi  // i />         :: :: indexed_infer_mem_value
    | </ Ci ; Li ; Ni |- mu_valuei => yi , base_typei , termi  // i />                 :: :: indexed_infer_mu_value
    | </ Ci ; Li ; Ni |- mu_pexpr_auxi => reti  // i />                                :: :: indexed_infer_mu_pexpr_aux
    | </ mu_patterni : base_typei ~> Ci  // i />                                       :: :: indexed_pattern
    | </ Ci ; Li ; Ni |- mu_tpexpri <= reti // i />                                    :: :: indexed_check_mu_tpexpr

defns
  mem_value_jtype :: '' ::=

% duplication going on here (could factor out int, ptr, arr, and struct rules)
defn
    C ; L ; N |- ty_mem_value => mem y , base_type , term :: :: Val_Obj_Mem :: Val_Obj_Mem_ by


    ---------------------------------------------------------------------------------- :: Int
    C ; L ; N |- int ty_mem_int => mem y , integer , y = int of_mem_int ty_mem_int _bt


    -------------------------------------------------------- :: Ptr_Null
    C ; L ; N |- nullptr => mem y , loc , y = nullop _bt _bt


    % ASK: is this a ident/Symbol_sym an identifier, or just because of A-normalisation?
    --------------------------------------------------------- :: Ptr_Func
    C ; L ; N |- funcptr ident => mem y , loc , y = ident _bt


    ---------------------------------------------------------------------- :: Ptr_Conc
    C ; L ; N |- concptr ty_nat => mem y , loc , y = ptr of_nat ty_nat _bt


    </ C ; L ; N |- ty_mem_valuei => mem yi , base_type , termi  // i />
    -------------------------------------------------------------------------- :: Arr
    C ; L ; N |- array ( </ ty_mem_valuei // i /> ) => mem y , array base_type ,  /\\ ( </  [ y [ int Z_ti ] _bt / yi ] termi // i /> ) _bt


    </ C ; L ; N |- ty_mem_valuei => mem yi , base_typei , termi  // i />
    --------------------------------------------------------------------- :: Struct
    C ; L ; N |- ( struct ty_tag ) { </ . Symbol_identifieri = ty_mem_valuei // i /> } => mem y , struct ty_tag ,  /\\ ( </ [ ty_tag y . Symbol_identifieri _bt / yi ] termi // i /> ) _bt

    % NOT IMPLEMENTED: union Symbol_sym Symbol_identifier

defns
  value_jtype :: '' ::=

defn
    C ; L ; N |- mu_object_value => obj tyvar_sym , base_type , term :: :: Val_Obj :: Val_Obj_ by


    ------------------------------------------------------------------------------ :: Int
    C ; L ; N |- ty_mem_int => obj y , integer , y = int of_mem_int ty_mem_int _bt


    -------------------------------------------------------- :: Ptr_Null
    C ; L ; N |- nullptr => obj y , loc , y = nullop _bt _bt


    % ASK: is this a ident/Symbol_sym an identifier, or just because of A-normalisation?
    --------------------------------------------------------- :: Ptr_Func
    C ; L ; N |- funcptr ident => obj y , loc , y = ident _bt


    ---------------------------------------------------------------------- :: Ptr_Conc
    C ; L ; N |- concptr ty_nat => obj y , loc , y = ptr of_nat ty_nat _bt


    % only instance of mutually recursive call to mu_value_judgement, can be inlined away
    </ C ; L ; N |- mu_loaded_valuei => yi , base_type , termi // i />
    ------------------------------------------------------------------------------------------------------------------------------------------ :: Arr
    C ; L ; N |- array ( </ mu_loaded_valuei // i /> ) => obj y , array base_type ,  /\\ ( </  [ y [ int Z_ti ] _bt / yi ] termi // i /> ) _bt


    Symbol_sym : struct ty_tag & </ Symbol_identifieri : T_cti // i /> inEnv Globals
    </ C ; L ; N |- ty_mem_valuei => mem yi , base_typei , termi  // i />
    -------------------------------------------------------------------------------- :: Struct
    C ; L ; N |- ( struct ty_tag ) { </ . Symbol_identifieri : T_cti = ty_mem_valuei //  i /> } => obj y , struct ty_tag ,  /\\ ( </ [ ty_tag y . Symbol_identifieri _bt / yi ] termi // i /> ) _bt


    % NOT IMPLEMENTED: union
    % UNSUPPORTED: floats

defn
    C ; L ; N |- mu_value => tyvar_sym , base_type , term :: :: Val :: Val_ by


    C ; L ; N |- mu_object_value => obj y , base_type , term
    -------------------------------------------------------- :: Obj
    C ; L ; N |- mu_object_value => y , base_type , term


    C ; L ; N |- mu_object_value => obj y , base_type , term
    -------------------------------------------------------------- :: Loaded
    C ; L ; N |- specified mu_object_value => y , base_type , term


    ------------------------------------------- :: Unit
    C ; L ; N |- Unit => y , unit , y = ( ) _bt


    -------------------------------------------- :: True
    C ; L ; N |- True => y , bool , y = true _bt


    ---------------------------------------------- :: False
    C ; L ; N |- False => y , bool , y = false _bt


    C ; L ; N |- mu_value1 =>  y1 , base_type , term1 .. C ; L ; N |- mu_valuen => yn , base_type , termn
    ----------------------------------------------------------------------------------------------------- :: List
    C ; L ; N |- base_type [ mu_value1 , .. , mu_valuen ] => y , [ base_type ] ,  /\\ ( [ y ^ ty_int1 _bt / y1 ] term1 , .. , [ y ^ ty_intn _bt / yn ] termn ) _bt


    C ; L ; N |- mu_value1 =>  y1 , base_type1 , term1 .. C ; L ; N |- mu_valuen => yn , base_typen , termn
    ------------------------------------------------------------------------------------------------------- :: Tuple
    C ; L ; N |- ( mu_value1 , .. , mu_valuen ) => y , ( base_type1 , .. , base_typen ) ,  /\\ ( [ y ^ ty_int1 _bt / y1 ] term1 , .. , [ y ^ ty_intn _bt / yn ] termn ) _bt


defns
  pexpr_jtype :: '' ::=

defn
    C ; L ; N |- mu_pexpr_aux => ret :: :: PExpr_Aux :: PExpr_Aux_ by


    x : base_type inEnv C
    ------------------------------------------------------- :: Var
    C ; L ; N |- x => sigma y  : base_type . y = x _bt /\ I


    % DEFER: globals (needs resources)


    C ; L ; N |- mu_value => y , base_type , term
    -------------------------------------------------------- :: Val
    C ; L ; N |- mu_value => sigma y : base_type . term /\ I


    % NOT IMPLEMENTED: constrained

    smt ( N => false /\ I )
    ------------------------------------------- :: Error
    C ; L ; N |- error ( ty_string , v ) => ret


    -------------------------------------------------------------------------------- :: Ctor_Nil
    C ; L ; N |- Nil base_type ( ) => sigma y : [ base_type ] . y = nil _bt _bt /\ I


    C ; L ; N |- v1 => sigma _ : base_type . _r
    C ; L ; N |- v2 => sigma _ : [ base_type ] . _r
    ------------------------------------------------------------------------------------- :: Ctor_Cons
    C ; L ; N |- Cons ( v1, v2 ) => sigma y : [ base_type ] . y = cons v1 v2 _bt _bt /\ I


    C ; L ; N |- v1 => sigma _ : base_type1 . _r ..  C ; L ; N |- vn => sigma _ : base_typen . _r
    --------------------------------------------------------------------------------------------------------------------- :: Ctor_Tuple
    C ; L ; N |- Tuple ( v1 , .. , vn ) => sigma y : ( base_type1 , .. , base_typen ) . y = ( v1 , .. , vn ) _bt _bt /\ I


    % TODO - empty arrays

    C ; L ; N |- v1 => sigma _ : base_type . _r ..  C ; L ; N |- vn => sigma _ : base_type . _r
    ------------------------------------------------------------------------------------------------------------------------------------------------- :: Ctor_Array
    C ; L ; N |- Array ( v1, .. , vn ) => sigma y : array base_type . /\\ ( y [ int Z_t1 ] _bt = v1 _bt , .. , y [ int Z_tn ] _bt = vn _bt ) _bt /\ I


    C ; L ; N |- v => sigma _ : base_type . _r
    -------------------------------------------------------------------- :: Ctor_Specified
    C ; L ; N |- Specified ( v ) => sigma y : base_type . y = v _bt /\ I


    % Unimplemented:
    % Ivmax       :: :: ivmax       {{ com max integer value              }} % : ctype -> integer
    % Ivmin       :: :: ivmin       {{ com min integer value              }} % : ctype -> integer
    % Ivsizeof    :: :: ivsizeof    {{ com sizeof value                   }} % : ctype -> integer
    % Ivalignof   :: :: ivalignof   {{ com alignof value                  }} % : ctype -> integer
    % IvCOMPL     :: :: ivCOMPL     {{ com bitwise complement             }} % : ctype -> integer -> integer
    % IvAND       :: :: ivAND       {{ com bitwise AND                    }} % : ctype -> integer -> integer -> integer
    % IvOR        :: :: ivOR        {{ com bitwise OR                     }} % : ctype -> integer -> integer -> integer
    % IvXOR       :: :: ivXOR       {{ com bitwise XOR                    }} % : ctype -> integer -> integer -> integer

    % Unsupported
    % Fvfromint   :: :: fvfromint   {{ com cast integer to floating value }} % : integer -> floating
    % Ivfromfloat :: :: ivfromfloat {{ com cast floating to integer value }} % : ctype -> floating -> integer


    C ; L ; N |- v1 => sigma _ : loc . _r
    C ; L ; N |- v2 => sigma _ : integer . _r
    --------------------------------------------------------------------------------------------------------------- :: Array_Shift
    C ; L ; N |- array_shift ( v1 , ct , v2 ) => sigma y : loc . y = v1 +ptr v2 * int of_ctype ct _bt  _bt _bt /\ I


    % TODO member_shift


    --------------------------------------------------------------------- :: Not
    C ; L ; N |- not ( v ) => sigma y : bool . y = ( neg v _bt ) _bt /\ I


    % TODO: op
    % arithmetic operators (integer -> integer -> integer)
    % +     :: :: Add   {{ tex \texttt{+}         }} {{ com addition       }}
    % -     :: :: Sub   {{ tex \texttt{-}         }} {{ com subtraction    }}
    % *     :: :: Mul   {{ tex \texttt{*}         }} {{ com multiplication }}
    % /     :: :: Div   {{ tex \texttt{/}         }} {{ com division       }}
    % rem_t :: :: Rem_t                              {{ com modulus        }}
    % rem_f :: :: Rem_f                              {{ com remainder      }}
    % ^     :: :: Exp   {{ tex \texttt{\char`^}   }} {{ com exponentiation }}
    % relational operators ( integer -> integer -> bool)
    % =     :: :: Eq    {{ tex \texttt{=}         }} {{ com equality, defined both for integer and C types }}
    % >     :: :: Gt    {{ tex \texttt{>}         }} {{ com greater than                                   }}
    % <     :: :: Lt    {{ tex \texttt{<}         }} {{ com less than                                      }}
    % >=    :: :: Ge    {{ tex \texttt{>=}        }} {{ com greater than or equal to                       }}
    % <=    :: :: Le    {{ tex \texttt{<=}        }} {{ com less than or equal to                          }}
    % logical connectives ( bool -> bool -> bool)
    % /\    :: :: And   {{ tex \texttt{/\char`\\} }} {{ com conjucntion }}
    % \/    :: :: Or    {{ tex \texttt{\char`\\/} }} {{ com disjunction }}

    % NOT IMPLEMENTED: op ~ struct, union, memberof

    % TODO call spine

    % DEFER conv_int

    % TODO: assert_undef, bool_to_integer, wrapI

defns
  pattern_jtype :: '' ::=

defn
  mu_pattern : base_type ~> C :: :: Pattern_ :: Pattern_ by

  % TODO

defn
  mu_sym_or_pattern : base_type ~> C :: :: Sym_Or_Pattern :: Sym_Or_Pattern by

  % TODO

defns
  tpexpr_jtype :: '' ::=

defn
  C ; L ; N |- mu_pexpr => ret :: :: PExpr_ :: PExpr_ by


  C ; L ; N |- mu_pexpr_aux => ret
  ------------------------------------------------------- :: Aux
  C ; L ; N |- ty_loc annots tyvar_TY mu_pexpr_aux => ret


defn
  C ; L ; N |- mu_tpexpr <= ret :: :: TPExpr :: TPExpr_ by


  C ; L ; N |- mu_tpexpr_aux <= ret
  -------------------------------------------------------- :: Aux
  C ; L ; N |- ty_loc annots tyvar_TY mu_tpexpr_aux <= ret


defn
  C ; L ; N |- mu_tpexpr_aux <= ret :: :: TPExpr_Aux :: TPExpr_Aux_ by


  smt ( N => false /\ I )
  ---------------------------------------- :: Undef
  C ; L ; N |- undef ty_loc UB_name <= ret


  C ; L ; N |- v => sigma _ : bool . _r
  % ASK boundary between inference/checking, should there be an SMT rule here?
  C ; L ; N , v = true  _bt |- mu_tpexpr1 <= ret
  C ; L ; N , v = false _bt |- mu_tpexpr2 <= ret
  -------------------------------------------------------- :: If
  C ; L ; N |- if v then mu_tpexpr1 else mu_tpexpr2 <= ret


  % this relies on a theorem that ret consists only of logical constraints
  C ; L ; N |- v => sigma _ : base_type . ret'
  smt ( N , ret'  => ret )
  ------------------------------------------------ :: Done
  C ; L ; N |- done v <= sigma y : base_type . ret


  C ; L ; N |- mu_pexpr => sigma y : base_type . ret'
  mu_sym_or_pattern : base_type ~> C'
  C , fresh ( C' ) ; L ; N |- [ fresh ( C' ) / C' ] mu_tpexpr <= ret
  ------------------------------------------------------------------ :: Let
  C ; L ; N |- let mu_sym_or_pattern = mu_pexpr in mu_tpexpr <= ret


  C ; L ; N |- v => sigma _ : base_type . _r
  % ASK boundary between inference/checking, should there be an SMT here?
  </ mu_patterni : base_type ~> Ci // i />
  </ C , fresh ( Ci ) ; L ; N |- [ fresh ( Ci ) / Ci ] mu_tpexpri <= ret // i />
  ------------------------------------------------------------------------------ :: Case
  C ; L ; N |- case v of </ | mu_patterni => mu_tpexpri // i /> end <= ret


defns
  expr_jtype :: '' ::=

defn
  C ; L ; N ; R |- mu_action_aux => ret :: :: Action :: Action_ by


  C ; L ; N |- v => sigma _ : integer . _r
  ---------------------------------------- :: Create
  C ; L ; N ; cdot |- create ( v , ct ) Symbol_prefix => sigma yp : loc . exists v' : of_ctype ( ct ) . representable ( ct ast , yp ) _bt /\ alignedI ( v , yp ) _bt /\ ct ( true ) ( yp , [ ] |-> [ v' , false ] ) *s I

  % NOT IMPLEMENTED:
  % C ; L ; N ; cdot |-> create_readonly ( vp , ct , v ) Symbol_prefix => ??

  % ASK: implementation requires resource with false and default?
  % ASK: what is Access Store/Kill?
  % ASK: will typing vp or v2 require resources?
  C ; L ; N |- vp => sigma _ : loc . _r
  C ; L ; N |- v2 => sigma _ : of_ctype ( ct ) . _r
  smt ( N => representable ( ct , v2 ) _bt /\ I )
  ------------------------------------------------- :: Store
  C ; L ; N ; cdot , ct ( true ) ( vp , [ ] |-> [ v1 , _b ] ) |- store ( _b , ct , vp , v2 , _mem_order ) => sigma _ : unit . ct ( true ) ( vp , [ ] |-> [ v2 , true ] ) *s I


  % ASK: implementation requires resource with false and default?
  % ASK: what is Access Store/Kill?
  % ASK: will typing vp or v2 require resources?
  C ; L ; N |- vp => sigma _ : loc . _r
  ------------------------------------------------------------------------------------------------------------- :: Kill_Static
  C ; L ; N ; cdot , ct ( true ) ( vp , [ ] |-> [ v1 , _b ] ) |-  kill ( static ct , vp ) => sigma _ : unit . I


  % NOT IMPLEMENTED:
  % C ; L ; N ; ?? |- kill ( dynamic , v ) => ??


% mu_action_aux {{ tex action\_aux }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions }}
%   | alloc ( ty_asym1 , ty_asym2 ) Symbol_prefix                                                         :: :: Alloc
%   | kill ( m_kill_kind , ty_asym )                                                                      :: :: Kill {{ com the boolean indicates whether the action is dynamic (i.e. free()) }}
%   | store ( ty_bool , ty_act , ty_asym1 , ty_asym2 , Cmm_memory_order )                                 :: :: Store {{ com the boolean indicates whether the store is locking }}
%   | load ( ty_act , ty_asym , Cmm_memory_order )                                                        :: :: Load
%   | rmw ( ty_act ,  ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )            :: :: RMW
%   | fence ( Cmm_memory_order )                                                                          :: :: Fence
%   | cmp_exch_strong ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: CompareExchangeStrong
%   | cmp_exch_weak ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )   :: :: CompareExchangeWeak
%   | linux_fence ( Linux_linux_memory_order )                                                            :: :: LinuxFence
%   | linux_load ( ty_act , ty_asym , Linux_linux_memory_order )                                          :: :: LinuxLoad
%   | linux_store ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                             :: :: LinuxStore
%   | linux_rmw ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                               :: :: LinuxRMW

defn
  C ; L ; N ; R |- mu_expr_aux => ret :: :: Expr_Aux :: Expr_Aux_ by


  C ; L ; N |- mu_pexpr => ret
  -------------------------------------------- :: Pure
  C ; L ; N ; cdot |- pure ( mu_pexpr ) => ret


  C ; L ; N ; R |- mu_action_aux => ret
  -------------------------------------------- :: Action
  C ; L ; N ; R |- ty_loc mu_action_aux => ret


  C ; L ; N ; R |- mu_action_aux => ret
  ---------------------------------------------------- :: Neg_Action
  C ; L ; N ; R |- neg ( ty_loc mu_action_aux ) => ret

  % memop ( mu_memop )                                    :: :: memop  {{ com pointer op involving memory }}
  % skip                                                  :: :: skip   {{ com skip                        }}
  % ccall ( ty_act , ty_asym , </ ty_asymi // , // i /> ) :: :: ccall  {{ com C function call             }}
  % pcall ( mu_name , </ ty_asymi // , // i /> )          :: :: proc   {{ com procedure call              }}
